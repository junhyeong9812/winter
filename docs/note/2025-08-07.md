# Java 내장 함수 완전 가이드 (상세 주석 포함)

## 목차
1. [System 클래스의 깊이 있는 이해](#1-system-클래스의-깊이-있는-이해)
2. [Math 클래스 완전 정복](#2-math-클래스-완전-정복)
3. [String 클래스의 모든 것](#3-string-클래스의-모든-것)
4. [Collection Framework 심화](#4-collection-framework-심화)
5. [Java 8+ 새로운 기능들](#5-java-8-새로운-기능들)
6. [날짜/시간 API 완전 가이드](#6-날짜시간-api-완전-가이드)
7. [파일 I/O 심화](#7-파일-io-심화)
8. [스레드와 동시성](#8-스레드와-동시성)
9. [내부 구조와 성능 이해](#9-내부-구조와-성능-이해)

---

## 1. System 클래스의 깊이 있는 이해

### 1.1 System 클래스 구조

```java
public final class System {
    public static final InputStream in;    // 표준 입력
    public static final PrintStream out;   // 표준 출력
    public static final PrintStream err;   // 표준 에러
}
```

**설명:**
- `System` 클래스는 시스템 레벨의 기능들을 제공하는 final 클래스입니다.
- `in`: 콘솔로부터 입력을 받는 표준 입력 스트림 (키보드 입력)
- `out`: 콘솔로 출력하는 표준 출력 스트림 (일반 출력)
- `err`: 에러 메시지를 출력하는 표준 에러 스트림 (에러 출력)
- 모든 필드가 static final로 선언되어 전역적으로 접근 가능하며 변경 불가능합니다.

### 1.2 출력 관련 메서드들

```java
// 기본 출력 메서드들
System.out.print("텍스트");           // 줄바꿈 없음
System.out.println("텍스트");         // 줄바꿈 포함
System.out.printf("%d %s", 10, "개"); // 포맷 출력

// 내부 동작 원리
PrintStream out = System.out;
out.write("Hello".getBytes());  // 바이트 레벨 출력
        out.flush();                    // 버퍼 강제 비우기
```

**설명:**
- `print()`: 문자열을 출력하되 줄바꿈 문자(\n)를 추가하지 않습니다.
- `println()`: 문자열을 출력한 후 줄바꿈 문자를 자동으로 추가합니다.
- `printf()`: C 스타일의 포맷 문자열을 사용하여 형식화된 출력을 제공합니다.
- `write()`: 바이트 배열을 직접 출력 스트림에 씁니다.
- `flush()`: 출력 버퍼에 남아있는 데이터를 강제로 출력합니다.

```java
// 고급 출력 기법
// 포맷 지정자들
System.out.printf("정수: %d%n", 42);
System.out.printf("실수: %.2f%n", 3.14159);
System.out.printf("문자열: %10s%n", "hello");  // 10자리 우측 정렬
System.out.printf("문자열: %-10s%n", "hello"); // 10자리 좌측 정렬
System.out.printf("16진수: %x%n", 255);

// 출력 스트림 리다이렉션
PrintStream originalOut = System.out;
try (PrintStream fileOut = new PrintStream("output.txt")) {
        System.setOut(fileOut);
    System.out.println("파일로 출력됨");
    System.setOut(originalOut);  // 원래대로 복구
}
```

**설명:**
- `%d`: 정수(decimal)를 출력하는 포맷 지정자
- `%.2f`: 소수점 둘째 자리까지 실수(float)를 출력
- `%10s`: 10자리 공간에 문자열을 우측 정렬하여 출력
- `%-10s`: 10자리 공간에 문자열을 좌측 정렬하여 출력
- `%x`: 16진수(hexadecimal)로 숫자를 출력
- `%n`: 플랫폼 독립적인 줄바꿈 문자 (Windows: \r\n, Unix: \n)
- `System.setOut()`: 표준 출력을 다른 스트림으로 리다이렉션합니다.

### 1.3 시간 관련 메서드들

```java
long startTime = System.currentTimeMillis();
// 작업 수행
Thread.sleep(1000);
long endTime = System.currentTimeMillis();
System.out.println("실행 시간: " + (endTime - startTime) + "ms");
```

**설명:**
- `System.currentTimeMillis()`: 1970년 1월 1일 00:00:00 UTC부터 현재까지의 경과 시간을 밀리초 단위로 반환합니다.
- 이는 Unix timestamp의 밀리초 버전으로, 시간 측정이나 로그 타임스탬프에 주로 사용됩니다.
- 시스템 시계에 의존하므로 시스템 시간 변경에 영향을 받을 수 있습니다.

```java
long startNano = System.nanoTime();
// 정밀한 측정이 필요한 작업
Collections.sort(largeList);
long duration = System.nanoTime() - startNano;
System.out.println("나노초 단위 실행시간: " + duration);
```

**설명:**
- `System.nanoTime()`: 고정밀도 시간 측정을 위한 메서드로 나노초 단위의 값을 반환합니다.
- 절대적인 시간이 아닌 상대적인 시간 차이 측정에만 사용해야 합니다.
- 시스템 시간 변경에 영향을 받지 않으므로 성능 측정에 더 적합합니다.
- JVM이 제공하는 가장 정밀한 타이머이며, 실제 정밀도는 하드웨어에 따라 다릅니다.

### 1.4 시스템 속성과 환경변수

```java
// 시스템 속성 읽기
String javaVersion = System.getProperty("java.version");
String osName = System.getProperty("os.name");
String userHome = System.getProperty("user.home");
String fileSeparator = System.getProperty("file.separator");

// 환경변수 읽기
Map<String, String> envVars = System.getenv();
String path = System.getenv("PATH");
String javaHome = System.getenv("JAVA_HOME");

// 시스템 속성 설정
System.setProperty("myapp.config", "development");
```

**설명:**
- `System.getProperty()`: JVM의 시스템 속성(System Properties)을 조회합니다. 이는 JVM 실행 시 -D 옵션으로 설정되거나 JVM이 자동으로 설정한 속성들입니다.
- `java.version`: 현재 실행 중인 Java 버전 정보
- `os.name`: 운영체제 이름 (Windows 10, Linux, Mac OS X 등)
- `user.home`: 현재 사용자의 홈 디렉토리 경로
- `file.separator`: 운영체제별 파일 경로 구분자 (Windows: \, Unix: /)
- `System.getenv()`: 운영체제의 환경변수를 조회합니다. 매개변수 없이 호출하면 모든 환경변수를 Map으로 반환합니다.
- `PATH`: 실행파일을 찾기 위한 디렉토리 경로들
- `JAVA_HOME`: Java 설치 경로
- `System.setProperty()`: 런타임에 시스템 속성을 설정합니다.

---

## 2. Math 클래스 완전 정복

### 2.1 Math 클래스의 내부 구조

```java
public final class Math {
    public static final double E = 2.7182818284590452354;
    public static final double PI = 3.14159265358979323846;

    public static native double sin(double a);  // native 메서드
    public static native double cos(double a);
}
```

**설명:**
- `Math` 클래스는 수학적 계산을 위한 정적 메서드들을 제공하는 final 클래스입니다.
- `E`: 자연로그의 밑(오일러 수) 약 2.718281828...
- `PI`: 원주율 π, 약 3.141592653...
- `native` 메서드: JNI(Java Native Interface)를 통해 운영체제 레벨의 최적화된 수학 함수를 호출합니다.
- 이로 인해 Java의 수학 연산은 매우 빠르고 정확합니다.

### 2.2 기본 수학 연산의 깊이 있는 활용

```java
// 절댓값 - 모든 숫자 타입 지원
int absInt = Math.abs(-42);           // 42
long absLong = Math.abs(-42L);        // 42L
float absFloat = Math.abs(-3.14f);    // 3.14f
double absDouble = Math.abs(-3.14);   // 3.14

// 최대값/최소값 - 오버로딩된 메서드들
int maxInt = Math.max(10, 20);
double maxDouble = Math.max(10.5, 20.3);
float minFloat = Math.min(3.14f, 2.71f);

// 실무 활용 예시: 범위 제한 함수
public static double clamp(double value, double min, double max) {
    return Math.max(min, Math.min(max, value));
}
```

**설명:**
- `Math.abs()`: 주어진 숫자의 절댓값(양수)을 반환합니다. 모든 기본 숫자 타입(int, long, float, double)에 대해 오버로딩되어 있습니다.
- `Math.max()`: 두 값 중 큰 값을 반환합니다.
- `Math.min()`: 두 값 중 작은 값을 반환합니다.
- `clamp()` 함수: 값을 지정된 범위 내로 제한하는 유틸리티 함수입니다. 게임 프로그래밍이나 UI에서 값 범위 제한에 자주 사용됩니다.

```java
// 거듭제곱
double power = Math.pow(2, 8);        // 256.0
double cube = Math.pow(3, 3);         // 27.0

// 제곱근과 세제곱근
double sqrt = Math.sqrt(16);          // 4.0
double cbrt = Math.cbrt(27);          // 3.0 (세제곱근)

// 지수와 로그
double exp = Math.exp(1);             // e^1 = 2.718...
double log = Math.log(Math.E);        // ln(e) = 1.0
double log10 = Math.log10(100);       // log₁₀(100) = 2.0

// 실무 예시: 복리 계산
public static double compoundInterest(double principal, double rate, int years) {
    return principal * Math.pow(1 + rate, years);
}
```

**설명:**
- `Math.pow(base, exponent)`: 밑수를 지수만큼 거듭제곱한 결과를 반환합니다.
- `Math.sqrt()`: 제곱근(square root)을 계산합니다.
- `Math.cbrt()`: 세제곱근(cube root)을 계산합니다.
- `Math.exp()`: e^x (자연지수함수)를 계산합니다.
- `Math.log()`: 자연로그(ln, 밑이 e인 로그)를 계산합니다.
- `Math.log10()`: 상용로그(밑이 10인 로그)를 계산합니다.
- `compoundInterest()`: 복리 이자를 계산하는 실무 예제입니다.

### 2.3 삼각함수와 각도 변환

```java
// 각도를 라디안으로 변환
double degrees = 90;
double radians = Math.toRadians(degrees);  // π/2
double backToDegrees = Math.toDegrees(radians);  // 90.0

// 삼각함수
double sin90 = Math.sin(Math.toRadians(90));  // 1.0
double cos0 = Math.cos(0);                    // 1.0
double tan45 = Math.tan(Math.toRadians(45));  // 1.0

// 역삼각함수
double asin = Math.asin(1);           // π/2
double acos = Math.acos(0);           // π/2
double atan = Math.atan(1);           // π/4

// 실무 예시: 좌표계 변환
public static class Point2D {
    public static Point2D polarToCartesian(double r, double theta) {
        return new Point2D(
                r * Math.cos(theta),
                r * Math.sin(theta)
        );
    }
}
```

**설명:**
- `Math.toRadians()`: 도(degree)를 라디안(radian)으로 변환합니다. (도 × π/180)
- `Math.toDegrees()`: 라디안을 도로 변환합니다. (라디안 × 180/π)
- `Math.sin()`, `Math.cos()`, `Math.tan()`: 기본 삼각함수들로, 매개변수는 라디안 단위입니다.
- `Math.asin()`, `Math.acos()`, `Math.atan()`: 역삼각함수들로, 결과는 라디안 단위입니다.
- `polarToCartesian()`: 극좌표(반지름, 각도)를 직교좌표(x, y)로 변환하는 실무 예제입니다.

### 2.4 난수 생성의 심화

```java
// 기본 난수 (0.0 이상 1.0 미만)
double random = Math.random();

// 범위 지정 난수 생성 유틸리티
public class RandomUtils {
    // 정수 범위 난수 (min 이상 max 이하)
    public static int randomInt(int min, int max) {
        return (int)(Math.random() * (max - min + 1)) + min;
    }

    // 실수 범위 난수
    public static double randomDouble(double min, double max) {
        return Math.random() * (max - min) + min;
    }

    // 불린 난수 (확률 기반)
    public static boolean randomBoolean(double probability) {
        return Math.random() < probability;
    }
}

// Random 클래스 활용 (더 강력한 난수 생성)
Random rand = new Random();
int gaussianInt = (int)(rand.nextGaussian() * 10 + 50);  // 평균 50, 표준편차 10
```

**설명:**
- `Math.random()`: 0.0 이상 1.0 미만의 균등 분포 난수를 반환합니다.
- `randomInt()`: 지정된 정수 범위 내의 난수를 생성합니다.
- `randomDouble()`: 지정된 실수 범위 내의 난수를 생성합니다.
- `randomBoolean()`: 주어진 확률에 따라 true/false를 반환합니다.
- `Random` 클래스: Math.random()보다 더 많은 기능을 제공하며, 시드를 설정할 수 있어 재현 가능한 난수를 생성할 수 있습니다.
- `nextGaussian()`: 표준 정규분포(평균 0, 표준편차 1)를 따르는 난수를 생성합니다.

### 2.5 반올림 함수들의 정밀한 이해

```java
double value = 3.7;

// floor: 바닥 함수 (음의 무한대 방향)
Math.floor(3.7);   // 3.0
Math.floor(-3.7);  // -4.0

// ceil: 천장 함수 (양의 무한대 방향)
Math.ceil(3.2);    // 4.0
Math.ceil(-3.7);   // -3.0

// round: 가장 가까운 정수로 반올림
Math.round(3.7);   // 4
Math.round(3.2);   // 3
Math.round(-3.7);  // -4

// rint: 가장 가까운 짝수로 반올림 (banker's rounding)
Math.rint(2.5);    // 2.0
Math.rint(3.5);    // 4.0

// 소수점 N자리 반올림 유틸리티
public static double roundToDecimalPlaces(double value, int places) {
    double multiplier = Math.pow(10, places);
    return Math.round(value * multiplier) / multiplier;
}
```

**설명:**
- `Math.floor()`: 주어진 수보다 작거나 같은 가장 큰 정수를 반환합니다 (내림).
- `Math.ceil()`: 주어진 수보다 크거나 같은 가장 작은 정수를 반환합니다 (올림).
- `Math.round()`: 가장 가까운 정수로 반올림합니다. 0.5일 때는 올림합니다.
- `Math.rint()`: "round to nearest integer"의 줄임말로, IEEE 754 표준에 따라 가장 가까운 정수로 반올림하되, 정확히 중간값(0.5)일 때는 가장 가까운 짝수로 반올림합니다.
- `roundToDecimalPlaces()`: 임의의 소수점 자리수로 반올림하는 유틸리티 함수입니다.

---

## 3. String 클래스의 모든 것

### 3.1 String의 내부 구조 이해

```java
public final class String implements Serializable, Comparable<String> {
    private final byte[] value;  // Java 9+에서 char[]에서 byte[]로 변경
    private int hash;            // 해시코드 캐싱

    // String Pool 메커니즘
    public native String intern();
}
```

**설명:**
- `String` 클래스는 불변(immutable) 객체로 설계되었습니다.
- Java 9부터 내부 저장소가 `char[]`에서 `byte[]`로 변경되어 메모리 효율성이 향상되었습니다.
- `hash` 필드: 한 번 계산된 해시코드를 캐시하여 성능을 향상시킵니다.
- `intern()`: 문자열을 String Pool로 이동시켜 메모리를 절약할 수 있습니다.
- String Pool은 JVM의 힙 영역에 있는 특별한 공간으로, 동일한 문자열 리터럴의 중복을 방지합니다.

### 3.2 문자열 생성과 메모리 관리

```java
// 다양한 String 생성 방법과 메모리 차이
String literal = "Hello";           // String Pool에 저장
String newString = new String("Hello"); // Heap에 새 객체 생성
String interned = newString.intern();   // String Pool로 이동

// 동일성 vs 동등성
System.out.println(literal == interned);      // true (같은 참조)
System.out.println(literal == newString);     // false (다른 참조)
System.out.println(literal.equals(newString)); // true (내용 동일)
```

**설명:**
- 문자열 리터럴: 컴파일 타임에 String Pool에 저장되어 메모리를 절약합니다.
- `new String()`: 힙 메모리에 새로운 객체를 생성하므로 메모리를 더 사용합니다.
- `intern()`: 런타임에 문자열을 String Pool로 이동시킵니다.
- `==` 연산자: 참조(메모리 주소)를 비교합니다.
- `equals()` 메서드: 문자열의 실제 내용을 비교합니다.

### 3.3 문자열 검색과 추출 메서드들

```java
String text = "Java Programming Language";

// 기본 검색 메서드들
int index = text.indexOf("Program");        // 5
int lastIndex = text.lastIndexOf("a");      // 18
boolean contains = text.contains("Java");   // true
boolean startsWith = text.startsWith("Ja"); // true
boolean endsWith = text.endsWith("age");    // true

// 고급 검색 - 여러 위치에서 찾기
public static List<Integer> findAllOccurrences(String text, String pattern) {
    List<Integer> indices = new ArrayList<>();
    int index = text.indexOf(pattern);
    while (index != -1) {
        indices.add(index);
        index = text.indexOf(pattern, index + 1);
    }
    return indices;
}

// 문자열 추출
String sub1 = text.substring(5);        // "Programming Language"
String sub2 = text.substring(5, 16);    // "Programming"
char charAt = text.charAt(0);           // 'J'

// 안전한 문자 접근 (IndexOutOfBounds 방지)
public static char safeCharAt(String str, int index) {
    return (index >= 0 && index < str.length()) ? str.charAt(index) : '\0';
}
```

**설명:**
- `indexOf()`: 문자열에서 지정된 문자나 부분 문자열이 처음 나타나는 인덱스를 반환합니다. 찾지 못하면 -1을 반환합니다.
- `lastIndexOf()`: 문자열에서 지정된 문자나 부분 문자열이 마지막에 나타나는 인덱스를 반환합니다.
- `contains()`: 지정된 문자열이 포함되어 있는지 boolean으로 반환합니다.
- `startsWith()`: 문자열이 지정된 문자열로 시작하는지 확인합니다.
- `endsWith()`: 문자열이 지정된 문자열로 끝나는지 확인합니다.
- `substring()`: 문자열의 부분을 추출합니다. 시작 인덱스만 지정하면 끝까지, 끝 인덱스까지 지정하면 해당 범위만 추출합니다.
- `charAt()`: 지정된 인덱스의 문자를 반환합니다.
- `findAllOccurrences()`: 패턴이 나타나는 모든 위치를 찾는 유틸리티 함수입니다.
- `safeCharAt()`: 인덱스 범위를 확인하여 안전하게 문자에 접근하는 유틸리티 함수입니다.

### 3.4 문자열 변환과 조작

```java
String original = "  Java Programming  ";

// 대소문자 변환
String upper = original.toUpperCase();      // "  JAVA PROGRAMMING  "
String lower = original.toLowerCase();      // "  java programming  "

// 공백 제거
String trimmed = original.trim();           // "Java Programming"
String stripped = original.strip();         // Java 11+ (유니코드 공백도 제거)

// 문자열 치환
String replaced = original.replace(" ", "_");           // "__Java_Programming__"
String replaceFirst = original.replaceFirst("a", "A");  // "  JAva Programming  "
String replaceAll = original.replaceAll("\\s+", " ");  // " Java Programming "

// 정규표현식을 이용한 고급 치환
String text = "Phone: 010-1234-5678";
String masked = text.replaceAll("(\\d{3})-(\\d{4})-(\\d{4})", "$1-****-$3");
// "Phone: 010-****-5678"
```

**설명:**
- `toUpperCase()`: 모든 문자를 대문자로 변환합니다.
- `toLowerCase()`: 모든 문자를 소문자로 변환합니다.
- `trim()`: 문자열 앞뒤의 공백(space, tab, newline)을 제거합니다.
- `strip()`: Java 11에서 추가된 메서드로, 유니코드 공백 문자까지 제거합니다.
- `replace()`: 지정된 문자나 문자열을 모두 다른 문자열로 치환합니다.
- `replaceFirst()`: 첫 번째로 일치하는 부분만 치환합니다.
- `replaceAll()`: 정규표현식을 사용하여 일치하는 모든 부분을 치환합니다.
- 정규표현식 예시: `\\d{3}`는 3자리 숫자, `$1`, `$3`은 그룹 참조입니다.

### 3.5 문자열 분할과 결합

```java
String csv = "apple,banana,cherry,date";

// 기본 분할
String[] fruits = csv.split(",");
String[] limited = csv.split(",", 2);  // 최대 2개로 분할

// 정규표현식 분할
String text = "word1   word2\tword3\nword4";
String[] words = text.split("\\s+");   // 모든 종류의 공백으로 분할

// 문자열 결합
String joined = String.join(", ", fruits);  // "apple, banana, cherry, date"

// StringBuilder vs StringBuffer
StringBuilder sb = new StringBuilder();     // 단일 스레드용 (빠름)
StringBuffer sbuf = new StringBuffer();     // 멀티 스레드용 (동기화됨)

sb.append("Hello")
  .append(" ")
  .append("World")
  .insert(5, " Beautiful")
  .delete(6, 15)
  .reverse();

// StringJoiner (Java 8+)
StringJoiner joiner = new StringJoiner(", ", "[", "]");
joiner.add("A").add("B").add("C");
String result = joiner.toString();  // "[A, B, C]"
```

**설명:**
- `split()`: 지정된 정규표현식을 구분자로 사용하여 문자열을 배열로 분할합니다.
- 두 번째 매개변수로 분할 개수를 제한할 수 있습니다.
- `String.join()`: 배열이나 컬렉션의 요소들을 지정된 구분자로 연결합니다.
- `StringBuilder`: 단일 스레드 환경에서 문자열을 효율적으로 조작하기 위한 가변 문자열 클래스입니다.
- `StringBuffer`: 멀티 스레드 환경에서 안전한 문자열 조작을 위한 클래스로, 모든 메서드가 동기화됩니다.
- `append()`: 문자열을 끝에 추가합니다.
- `insert()`: 지정된 위치에 문자열을 삽입합니다.
- `delete()`: 지정된 범위의 문자들을 삭제합니다.
- `reverse()`: 문자열의 순서를 뒤집습니다.
- `StringJoiner`: 구분자, 접두사, 접미사를 설정하여 문자열을 조합할 수 있는 유틸리티 클래스입니다.

### 3.6 문자열 비교의 모든 것

```java
String s1 = "Hello";
String s2 = "hello";
String s3 = null;

// 기본 비교
boolean equals = s1.equals(s2);              // false
boolean equalsIgnoreCase = s1.equalsIgnoreCase(s2); // true

// Null-safe 비교
boolean safeEquals = Objects.equals(s1, s3); // false (null 처리됨)

// 사전식 비교
int compare = s1.compareTo(s2);              // 음수 (s1이 사전순으로 앞)
int compareIgnoreCase = s1.compareToIgnoreCase(s2); // 0 (동일)

// 문자열 패턴 매칭
boolean matches = "123".matches("\\d+");     // true (숫자만)
boolean phonePattern = "010-1234-5678".matches("\\d{3}-\\d{4}-\\d{4}"); // true
```

**설명:**
- `equals()`: 문자열의 내용을 비교하여 동일한지 확인합니다. 대소문자를 구분합니다.
- `equalsIgnoreCase()`: 대소문자를 구분하지 않고 문자열 내용을 비교합니다.
- `Objects.equals()`: null-safe한 비교를 제공합니다. 두 문자열 중 하나가 null이어도 NullPointerException이 발생하지 않습니다.
- `compareTo()`: 사전식 순서로 문자열을 비교합니다. 음수(현재 문자열이 앞), 0(동일), 양수(현재 문자열이 뒤)를 반환합니다.
- `compareToIgnoreCase()`: 대소문자를 구분하지 않고 사전식 비교를 수행합니다.
- `matches()`: 문자열이 주어진 정규표현식과 완전히 일치하는지 확인합니다.

---

## 4. Collection Framework 심화

### 4.1 List 계열의 완전 이해

#### ArrayList의 내부 구조

```java
public class ArrayList<E> implements List<E> {
    private static final int DEFAULT_CAPACITY = 10;
    private Object[] elementData;
    private int size;

    // 자동 크기 조정 (동적 배열)
    private void grow(int minCapacity) {
        int oldCapacity = elementData.length;
        int newCapacity = oldCapacity + (oldCapacity >> 1); // 1.5배 증가
    }
}
```

**설명:**
- `ArrayList`는 내부적으로 Object 배열을 사용하는 동적 배열입니다.
- `DEFAULT_CAPACITY`: 기본 초기 용량은 10개입니다.
- `elementData`: 실제 데이터를 저장하는 배열입니다.
- `size`: 현재 저장된 요소의 개수입니다.
- `grow()`: 배열이 가득 찰 때 용량을 1.5배로 증가시키는 메서드입니다.
- `>>` 연산자: 비트 시프트 연산으로, `>> 1`은 2로 나누는 것과 같습니다.

#### ArrayList 고급 활용

```java
List<String> list = new ArrayList<>();

// 기본 조작
list.add("Apple");
list.add(0, "Banana");              // 특정 위치에 삽입
list.set(0, "Blueberry");           // 특정 위치 값 변경
String removed = list.remove(0);     // 위치로 제거
boolean removed2 = list.remove("Apple"); // 값으로 제거

// 배치 처리
List<String> batch = Arrays.asList("A", "B", "C");
list.addAll(batch);                 // 전체 추가
list.addAll(1, batch);              // 특정 위치부터 추가
list.removeAll(batch);              // 일치하는 모든 요소 제거
list.retainAll(batch);              // 일치하는 요소만 유지

// 고급 검색
int index = list.indexOf("Apple");   // 첫 번째 위치
int lastIndex = list.lastIndexOf("Apple"); // 마지막 위치
List<String> subList = list.subList(1, 3);  // 부분 리스트 (view)

// 성능 최적화 팁
List<String> optimizedList = new ArrayList<>(1000); // 초기 용량 설정
list.trimToSize();                  // 메모리 최적화
```

**설명:**
- `add(index, element)`: 지정된 위치에 요소를 삽입하고, 기존 요소들은 뒤로 이동합니다.
- `set(index, element)`: 지정된 위치의 요소를 새 값으로 교체합니다.
- `remove(index)`: 지정된 위치의 요소를 제거하고 반환합니다.
- `remove(object)`: 지정된 객체와 일치하는 첫 번째 요소를 제거합니다.
- `addAll()`: 다른 컬렉션의 모든 요소를 추가합니다.
- `removeAll()`: 지정된 컬렉션에 포함된 모든 요소를 제거합니다.
- `retainAll()`: 지정된 컬렉션에 포함된 요소만 유지하고 나머지는 제거합니다.
- `subList()`: 원본 리스트의 부분 뷰를 반환합니다. 이 뷰를 수정하면 원본도 영향을 받습니다.
- `trimToSize()`: 내부 배열의 크기를 실제 요소 수에 맞게 조정하여 메모리를 절약합니다.

#### LinkedList vs ArrayList 성능 비교

```java
// LinkedList - 노드 기반 이중 연결 리스트
LinkedList<String> linkedList = new LinkedList<>();
linkedList.addFirst("First");       // O(1)
linkedList.addLast("Last");         // O(1)
linkedList.removeFirst();           // O(1)
linkedList.removeLast();            // O(1)

// 성능 비교 시나리오
// ArrayList: 인덱스 접근 O(1), 중간 삽입/삭제 O(n)
// LinkedList: 인덱스 접근 O(n), 양끝 삽입/삭제 O(1)
```

**설명:**
- `LinkedList`는 이중 연결 리스트로 구현되어 있습니다.
- `addFirst()`, `addLast()`: 리스트의 처음이나 끝에 요소를 추가합니다. 연결리스트 특성상 O(1) 시간이 걸립니다.
- `removeFirst()`, `removeLast()`: 리스트의 처음이나 끝 요소를 제거합니다.
- ArrayList는 배열 기반이므로 인덱스 접근이 빠르지만, 중간 삽입/삭제 시 요소들을 이동해야 합니다.
- LinkedList는 노드 연결 구조이므로 인덱스 접근 시 처음부터 순차 탐색해야 하지만, 삽입/삭제는 연결만 변경하면 됩니다.

### 4.2 Map 계열의 심화 활용

#### HashMap의 내부 구조 이해

```java
public class HashMap<K,V> implements Map<K,V> {
    static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16
    static final float DEFAULT_LOAD_FACTOR = 0.75f;

    transient Node<K,V>[] table;  // 해시 테이블
    transient int size;

    // 해시 충돌 해결: 체이닝과 트리화 (Java 8+)
    static final int TREEIFY_THRESHOLD = 8;
}
```

**설명:**
- `HashMap`은 해시 테이블을 기반으로 하는 Key-Value 저장소입니다.
- `DEFAULT_INITIAL_CAPACITY`: 기본 초기 용량은 16입니다. (`1 << 4`는 2^4 = 16을 의미)
- `DEFAULT_LOAD_FACTOR`: 기본 로드 팩터는 0.75입니다. 테이블이 75% 찰 때 크기를 증가시킵니다.
- `table`: 실제 데이터를 저장하는 해시 테이블 배열입니다.
- `TREEIFY_THRESHOLD`: Java 8부터 해시 충돌이 많이 발생하는 버킷은 연결리스트에서 레드-블랙 트리로 변환됩니다.
- `transient`: 직렬화 시 제외되는 필드를 나타냅니다.

#### Map의 고급 기능들

```java
Map<String, Integer> map = new HashMap<>();

// 기본 조작
map.put("apple", 100);
map.put("banana", 200);
Integer value = map.get("apple");            // 100
Integer defaultValue = map.getOrDefault("orange", 0); // 0

// Java 8+ 고급 메서드들
map.putIfAbsent("cherry", 300);              // 키가 없을 때만 추가
map.replace("apple", 150);                   // 키가 있을 때만 교체
map.replace("apple", 150, 175);              // 특정 값일 때만 교체

// 계산 기반 업데이트
map.compute("apple", (key, val) -> val == null ? 1 : val + 1);
        map.computeIfAbsent("grape", key -> key.length());
        map.computeIfPresent("banana", (key, val) -> val * 2);

// 병합 연산
        map.merge("apple", 50, Integer::sum);        // 기존 값과 합계

// 반복 처리
map.forEach((key, value) -> {
        System.out.println(key + ": " + value);
});

// 뷰 컬렉션 활용
Set<String> keys = map.keySet();             // 키 집합
Collection<Integer> values = map.values();   // 값 컬렉션
Set<Map.Entry<String, Integer>> entries = map.entrySet(); // 엔트리 집합
```

**설명:**
- `getOrDefault()`: 키가 존재하면 해당 값을, 없으면 기본값을 반환합니다.
- `putIfAbsent()`: 키가 없거나 값이 null일 때만 값을 추가합니다.
- `replace()`: 키가 존재할 때만 값을 교체합니다. 세 매개변수 버전은 기존 값이 일치할 때만 교체합니다.
- `compute()`: 키와 기존 값을 기반으로 새 값을 계산합니다.
- `computeIfAbsent()`: 키가 없을 때만 값을 계산하여 추가합니다.
- `computeIfPresent()`: 키가 있을 때만 값을 다시 계산합니다.
- `merge()`: 기존 값과 새 값을 병합 함수로 합칩니다.
- `forEach()`: 각 키-값 쌍에 대해 액션을 수행합니다.
- `keySet()`: 모든 키의 집합을 반환하는 뷰입니다.
- `values()`: 모든 값의 컬렉션을 반환하는 뷰입니다.
- `entrySet()`: 모든 키-값 엔트리의 집합을 반환하는 뷰입니다.

#### 특수한 Map 구현체들

```java
// TreeMap - 정렬된 맵
TreeMap<String, Integer> treeMap = new TreeMap<>();
treeMap.put("c", 3);
treeMap.put("a", 1);
treeMap.put("b", 2);
// 자동으로 키 순서로 정렬됨: {a=1, b=2, c=3}

// LinkedHashMap - 삽입 순서 유지
LinkedHashMap<String, Integer> linkedMap = new LinkedHashMap<>();

// ConcurrentHashMap - 스레드 안전
ConcurrentHashMap<String, Integer> concurrentMap = new ConcurrentHashMap<>();
```

**설명:**
- `TreeMap`: 레드-블랙 트리를 기반으로 하며, 키가 자동으로 정렬됩니다. 삽입/검색/삭제가 O(log n)입니다.
- `LinkedHashMap`: HashMap의 기능에 삽입 순서 또는 액세스 순서를 유지하는 기능을 추가합니다.
- `ConcurrentHashMap`: 멀티스레드 환경에서 안전하게 사용할 수 있는 HashMap입니다. 세그먼트 기반 락킹을 사용하여 성능을 최적화합니다.

### 4.3 Set 계열의 활용

```java
Set<String> hashSet = new HashSet<>();       // 해시 기반, 순서 없음
Set<String> linkedHashSet = new LinkedHashSet<>(); // 삽입 순서 유지
Set<String> treeSet = new TreeSet<>();       // 정렬된 집합

// Set 연산들
Set<String> set1 = new HashSet<>(Arrays.asList("A", "B", "C"));
Set<String> set2 = new HashSet<>(Arrays.asList("B", "C", "D"));

// 합집합
Set<String> union = new HashSet<>(set1);
union.addAll(set2);  // {A, B, C, D}

// 교집합
Set<String> intersection = new HashSet<>(set1);
intersection.retainAll(set2);  // {B, C}

// 차집합
Set<String> difference = new HashSet<>(set1);
difference.removeAll(set2);  // {A}

// 부분집합 확인
boolean isSubset = set2.containsAll(set1);
```

**설명:**
- `HashSet`: 해시 테이블을 사용하여 중복을 방지합니다. 요소의 순서는 보장되지 않습니다.
- `LinkedHashSet`: HashSet의 기능에 삽입 순서를 유지하는 기능을 추가합니다.
- `TreeSet`: 레드-블랙 트리를 사용하여 요소를 정렬된 상태로 유지합니다.
- `addAll()`: 합집합을 구할 때 사용합니다. 두 집합의 모든 요소를 포함합니다.
- `retainAll()`: 교집합을 구할 때 사용합니다. 두 집합에 공통으로 포함된 요소만 유지합니다.
- `removeAll()`: 차집합을 구할 때 사용합니다. 첫 번째 집합에서 두 번째 집합의 요소들을 제거합니다.
- `containsAll()`: 부분집합 관계를 확인합니다. 모든 요소가 포함되어 있는지 확인합니다.

---

## 5. Java 8+ 새로운 기능들

### 5.1 Stream API의 완전 정복

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie", "David", "Eve");

// 기본 스트림 연산
List<String> filtered = names.stream()
        .filter(name -> name.length() > 3)      // 중간 연산
        .map(String::toUpperCase)               // 중간 연산
        .sorted()                               // 중간 연산
        .collect(Collectors.toList());          // 최종 연산

// 다양한 중간 연산들
names.stream()
    .distinct()                             // 중복 제거
    .skip(2)                               // 처음 2개 건너뛰기
    .limit(3)                              // 최대 3개만
    .peek(System.out::println)             // 디버깅용 중간 처리
    .forEach(System.out::println);
```

**설명:**
- `Stream`은 함수형 프로그래밍 스타일로 컬렉션을 처리할 수 있게 해주는 API입니다.
- `filter()`: 조건에 맞는 요소만 통과시키는 중간 연산입니다.
- `map()`: 각 요소를 다른 형태로 변환하는 중간 연산입니다.
- `sorted()`: 요소를 정렬하는 중간 연산입니다.
- `collect()`: 스트림을 컬렉션으로 변환하는 최종 연산입니다.
- `distinct()`: 중복 요소를 제거하는 중간 연산입니다.
- `skip()`: 처음 n개 요소를 건너뛰는 중간 연산입니다.
- `limit()`: 최대 n개 요소만 처리하는 중간 연산입니다.
- `peek()`: 요소를 소비하지 않고 중간에 처리를 수행하는 중간 연산으로, 주로 디버깅에 사용됩니다.
- `forEach()`: 각 요소에 대해 액션을 수행하는 최종 연산입니다.

#### Stream의 내부 동작 원리

```java
// 지연 평가 (Lazy Evaluation) 예시
Stream<String> stream = names.stream()
        .filter(name -> {
            System.out.println("Filtering: " + name);
            return name.length() > 3;
        })
        .map(name -> {
            System.out.println("Mapping: " + name);
            return name.toUpperCase();
        });

// 여기까지는 아무것도 실행되지 않음!
// 최종 연산이 호출될 때 실행됨
List<String> result = stream.collect(Collectors.toList());
```

**설명:**
- `지연 평가(Lazy Evaluation)`: 스트림의 중간 연산들은 실제로 실행되지 않고 연산 파이프라인만 구성됩니다.
- 최종 연산이 호출되는 시점에 모든 중간 연산들이 함께 실행됩니다.
- 이는 불필요한 계산을 방지하고 성능을 최적화하는 중요한 특성입니다.
- 예시에서 `collect()`가 호출되기 전까지는 "Filtering"이나 "Mapping" 출력이 나타나지 않습니다.

### 5.2 고급 Collectors 활용

```java
List<Person> people = Arrays.asList(
        new Person("Alice", 25, "Engineering"),
        new Person("Bob", 30, "Marketing"),
        new Person("Charlie", 35, "Engineering")
);

// 그룹핑
Map<String, List<Person>> byDepartment = people.stream()
        .collect(Collectors.groupingBy(Person::getDepartment));

// 다단계 그룹핑
Map<String, Map<Integer, List<Person>>> byDeptAndAge = people.stream()
        .collect(Collectors.groupingBy(
                Person::getDepartment,
                Collectors.groupingBy(Person::getAge)
        ));

// 집계 연산과 함께 그룹핑
Map<String, Double> avgAgeByDept = people.stream()
        .collect(Collectors.groupingBy(
                Person::getDepartment,
                Collectors.averagingInt(Person::getAge)
        ));

// 커스텀 Collector
Map<String, String> customCollect = people.stream()
        .collect(Collectors.toMap(
                Person::getName,
                person -> person.getDepartment() + ":" + person.getAge(),
                (existing, replacement) -> existing  // 중복 키 처리
        ));
```

**설명:**
- `Collectors.groupingBy()`: 지정된 분류 함수에 따라 요소들을 그룹화합니다.
- `다단계 그룹핑`: 첫 번째 기준으로 그룹화한 후, 각 그룹을 다시 두 번째 기준으로 그룹화합니다.
- `Collectors.averagingInt()`: 그룹별로 정수 값의 평균을 계산합니다.
- `Collectors.toMap()`: 스트림을 Map으로 변환합니다. 키 추출 함수, 값 추출 함수, 중복 키 처리 함수를 제공할 수 있습니다.
- 중복 키 처리: 같은 키가 여러 개 있을 때의 처리 방식을 정의합니다.

### 5.3 Optional 클래스 완전 가이드

```java
import java.util.function.*;

// Optional 생성
Optional<String> optional1 = Optional.of("Hello");          // null이면 예외
Optional<String> optional2 = Optional.ofNullable(getName()); // null 허용
Optional<String> empty = Optional.empty();                   // 빈 Optional

// 값 확인과 추출
if (optional1.isPresent()) {
String value = optional1.get();
}

// 함수형 스타일 처리
        optional1.ifPresent(System.out::println);                   // 값이 있으면 실행
optional1.ifPresentOrElse(                                  // Java 9+
                                                            System.out::println,
    () -> System.out.println("No value")
);

// 기본값 처리
String result1 = optional2.orElse("Default");               // 즉시 평가
String result2 = optional2.orElseGet(() -> "Default");      // 지연 평가
String result3 = optional2.orElseThrow(() -> new RuntimeException("No value"));

// 변환과 필터링
Optional<Integer> length = optional1
        .filter(s -> s.length() > 3)
        .map(String::length);

Optional<String> upperCase = optional1
        .flatMap(s -> s.isEmpty() ? Optional.empty() : Optional.of(s.toUpperCase()));
```

**설명:**
- `Optional`은 null 값을 안전하게 처리하기 위한 컨테이너 클래스입니다.
- `Optional.of()`: null이 아닌 값으로 Optional을 생성합니다. null이면 NullPointerException을 던집니다.
- `Optional.ofNullable()`: null일 수도 있는 값으로 Optional을 생성합니다.
- `Optional.empty()`: 빈 Optional을 생성합니다.
- `isPresent()`: 값이 있는지 확인합니다.
- `get()`: 값을 추출하지만, 값이 없으면 예외를 던집니다. 사용을 권장하지 않습니다.
- `ifPresent()`: 값이 있으면 주어진 액션을 수행합니다.
- `ifPresentOrElse()`: 값이 있으면 첫 번째 액션을, 없으면 두 번째 액션을 수행합니다.
- `orElse()`: 값이 있으면 그 값을, 없으면 기본값을 반환합니다. 기본값은 즉시 평가됩니다.
- `orElseGet()`: 값이 있으면 그 값을, 없으면 Supplier로부터 기본값을 생성해 반환합니다. 지연 평가됩니다.
- `orElseThrow()`: 값이 있으면 그 값을, 없으면 예외를 던집니다.
- `filter()`: 조건에 맞으면 현재 Optional을, 아니면 빈 Optional을 반환합니다.
- `map()`: 값이 있으면 변환 함수를 적용하고, 없으면 빈 Optional을 반환합니다.
- `flatMap()`: 중첩된 Optional을 평면화합니다.

### 5.4 Lambda 표현식과 메서드 참조

```java
// Lambda 표현식의 다양한 형태
Runnable runnable = () -> System.out.println("Hello");
Consumer<String> printer = text -> System.out.println(text);
Function<String, Integer> lengthFunc = s -> s.length();
Predicate<String> isEmpty = s -> s.isEmpty();
BinaryOperator<Integer> adder = (a, b) -> a + b;

// 메서드 참조 종류
Consumer<String> methodRef1 = System.out::println;          // 정적 메서드 참조
Function<String, Integer> methodRef2 = String::length;      // 인스턴스 메서드 참조
Supplier<List<String>> methodRef3 = ArrayList::new;         // 생성자 참조

// 고급 람다 활용
List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5);

// 복잡한 조건 조합
Predicate<Integer> isEven = n -> n % 2 == 0;
Predicate<Integer> isPositive = n -> n > 0;
Predicate<Integer> evenAndPositive = isEven.and(isPositive);

List<Integer> filtered = numbers.stream()
        .filter(evenAndPositive)
        .collect(Collectors.toList());
```

**설명:**
- `Lambda 표현식`: 함수형 인터페이스의 인스턴스를 간결하게 표현하는 방법입니다.
- `Runnable`: 매개변수도 반환값도 없는 함수형 인터페이스입니다.
- `Consumer<T>`: 매개변수를 받고 반환값이 없는 함수형 인터페이스입니다.
- `Function<T,R>`: 매개변수를 받고 결과를 반환하는 함수형 인터페이스입니다.
- `Predicate<T>`: 매개변수를 받고 boolean을 반환하는 함수형 인터페이스입니다.
- `BinaryOperator<T>`: 같은 타입의 매개변수 2개를 받고 같은 타입을 반환하는 함수형 인터페이스입니다.
- `메서드 참조`: 기존 메서드를 람다 표현식처럼 사용할 수 있게 해줍니다.
- `System.out::println`: 정적 메서드 참조
- `String::length`: 인스턴스 메서드 참조
- `ArrayList::new`: 생성자 참조
- `and()`: Predicate를 AND 조건으로 결합합니다.

### 5.5 병렬 스트림 (Parallel Streams)

```java
List<Integer> largeList = IntStream.range(0, 1_000_000)
        .boxed()
        .collect(Collectors.toList());

// 순차 처리
long sequential = largeList.stream()
        .mapToInt(i -> i * i)
        .sum();

// 병렬 처리
long parallel = largeList.parallelStream()
        .mapToInt(i -> i * i)
        .sum();

// 병렬 처리 주의사항
// 1. 작은 데이터셋에서는 오히려 느릴 수 있음
// 2. 스레드 안전하지 않은 연산 주의
// 3. 순서에 의존하는 연산 주의
```

**설명:**
- `parallelStream()`: 스트림을 병렬로 처리합니다. 내부적으로 ForkJoinPool을 사용합니다.
- `IntStream.range()`: 지정된 범위의 정수 스트림을 생성합니다.
- `boxed()`: 기본 타입 스트림을 래퍼 타입 스트림으로 변환합니다.
- `mapToInt()`: 스트림 요소를 정수로 매핑하고 IntStream을 반환합니다.
- 병렬 처리는 CPU 집약적 작업에서 효과적이지만, 작은 데이터셋이나 I/O 작업에서는 오히려 성능이 저하될 수 있습니다.
- 스레드 안전하지 않은 컬렉션 수정이나 상태 변경 작업 시 주의가 필요합니다.

---

## 6. 날짜/시간 API 완전 가이드

### 6.1 Java 8 Time API 구조

```java
// 주요 클래스들
LocalDate date = LocalDate.now();           // 날짜만
LocalTime time = LocalTime.now();           // 시간만
LocalDateTime dateTime = LocalDateTime.now(); // 날짜 + 시간
ZonedDateTime zonedDateTime = ZonedDateTime.now(); // 시간대 포함
Instant instant = Instant.now();            // UTC 기준 타임스탬프
```

**설명:**
- `LocalDate`: 날짜 정보만을 담는 불변 클래스입니다 (년, 월, 일).
- `LocalTime`: 시간 정보만을 담는 불변 클래스입니다 (시, 분, 초, 나노초).
- `LocalDateTime`: 날짜와 시간을 모두 담지만 시간대 정보는 없는 클래스입니다.
- `ZonedDateTime`: 날짜, 시간, 시간대 정보를 모두 포함하는 클래스입니다.
- `Instant`: UTC 기준의 타임스탬프를 나타내는 클래스로, 기계적 시간 처리에 적합합니다.
- 모든 클래스는 불변(immutable)이고 스레드 안전합니다.

### 6.2 날짜 생성과 파싱

```java
// 다양한 생성 방법
LocalDate specificDate = LocalDate.of(2025, 8, 4);
LocalDate parsed = LocalDate.parse("2025-08-04");
LocalDate formatted = LocalDate.parse("04/08/2025",
        DateTimeFormatter.ofPattern("dd/MM/yyyy"));

// 현재 시간 기준 생성
LocalDate today = LocalDate.now();
LocalDate tomorrow = today.plusDays(1);
LocalDate lastWeek = today.minusWeeks(1);
LocalDate firstDayOfMonth = today.withDayOfMonth(1);
LocalDate firstDayOfYear = today.withDayOfYear(1);

// 상대적 날짜 계산
LocalDate nextMonday = today.with(TemporalAdjusters.next(DayOfWeek.MONDAY));
LocalDate lastDayOfMonth = today.with(TemporalAdjusters.lastDayOfMonth());
LocalDate firstMondayOfMonth = today.with(TemporalAdjusters.firstInMonth(DayOfWeek.MONDAY));
```

**설명:**
- `LocalDate.of()`: 특정 년, 월, 일로 날짜 객체를 생성합니다.
- `LocalDate.parse()`: 문자열을 파싱하여 날짜 객체를 생성합니다. 기본 형식은 ISO-8601(yyyy-MM-dd)입니다.
- `DateTimeFormatter.ofPattern()`: 사용자 정의 날짜 형식으로 파싱할 때 사용합니다.
- `plusDays()`, `minusWeeks()`: 날짜에 일정 기간을 더하거나 뺍니다.
- `withDayOfMonth()`: 월의 특정 일로 설정합니다.
- `withDayOfYear()`: 연도의 특정 일로 설정합니다.
- `TemporalAdjusters`: 복잡한 날짜 계산을 위한 유틸리티 클래스입니다.
- `next()`: 다음 특정 요일을 찾습니다.
- `lastDayOfMonth()`: 해당 월의 마지막 날을 반환합니다.
- `firstInMonth()`: 해당 월의 첫 번째 특정 요일을 찾습니다.

### 6.3 시간 계산과 비교

```java
LocalDate start = LocalDate.of(2025, 1, 1);
LocalDate end = LocalDate.of(2025, 12, 31);

// 기간 계산
Period period = Period.between(start, end);
System.out.println(period.getYears());      // 0
        System.out.println(period.getMonths());     // 11
        System.out.println(period.getDays());       // 30

// 정확한 일수 계산
long daysBetween = ChronoUnit.DAYS.between(start, end);
long weeksBetween = ChronoUnit.WEEKS.between(start, end);
long monthsBetween = ChronoUnit.MONTHS.between(start, end);

// 시간 계산
LocalTime startTime = LocalTime.of(9, 30);
LocalTime endTime = LocalTime.of(17, 45);
Duration duration = Duration.between(startTime, endTime);
long hours = duration.toHours();            // 8
long minutes = duration.toMinutes();        // 495

// 날짜 비교
boolean isBefore = start.isBefore(end);      // true
boolean isAfter = start.isAfter(end);        // false
boolean isEqual = start.isEqual(end);        // false
```

**설명:**
- `Period`: 날짜 기반의 기간을 나타냅니다 (년, 월, 일).
- `Period.between()`: 두 날짜 사이의 기간을 계산합니다.
- `getYears()`, `getMonths()`, `getDays()`: Period의 년, 월, 일 구성 요소를 반환합니다.
- `ChronoUnit`: 시간 단위를 나타내는 enum입니다.
- `ChronoUnit.DAYS.between()`: 두 날짜 사이의 정확한 일수를 계산합니다.
- `Duration`: 시간 기반의 기간을 나타냅니다 (시, 분, 초, 나노초).
- `Duration.between()`: 두 시간 사이의 지속 시간을 계산합니다.
- `toHours()`, `toMinutes()`: Duration을 시간 또는 분 단위로 변환합니다.
- `isBefore()`, `isAfter()`, `isEqual()`: 날짜 비교 메서드들입니다.

### 6.4 포맷팅과 파싱

```java
LocalDateTime now = LocalDateTime.now();

// 미리 정의된 포맷터
String iso = now.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME);
String basic = now.format(DateTimeFormatter.BASIC_ISO_DATE);

// 커스텀 포맷터
DateTimeFormatter custom = DateTimeFormatter.ofPattern("yyyy년 MM월 dd일 HH시 mm분");
String formatted = now.format(custom);

// 로케일 기반 포맷팅
DateTimeFormatter korean = DateTimeFormatter.ofPattern("yyyy년 M월 d일", Locale.KOREAN);
DateTimeFormatter english = DateTimeFormatter.ofPattern("MMM d, yyyy", Locale.ENGLISH);

// 파싱 시 오류 처리
try {
LocalDate parsed = LocalDate.parse("2025-13-01");  // 잘못된 월
} catch (DateTimeParseException e) {
        System.out.println("파싱 오류: " + e.getMessage());
        }
```

**설명:**
- `DateTimeFormatter`: 날짜/시간을 문자열로 포맷하거나 문자열을 파싱하는 데 사용됩니다.
- `ISO_LOCAL_DATE_TIME`: ISO-8601 표준 형식 (2025-08-07T14:30:15)
- `BASIC_ISO_DATE`: 기본 ISO 날짜 형식 (20250807)
- `ofPattern()`: 사용자 정의 패턴을 사용하여 포맷터를 생성합니다.
- `yyyy`: 4자리 년도, `MM`: 2자리 월, `dd`: 2자리 일, `HH`: 24시간제 시간, `mm`: 분
- `Locale`: 지역/언어별 포맷팅을 위한 클래스입니다.
- `M`: 1-2자리 월, `MMM`: 축약된 월 이름 (Jan, Feb 등)
- `DateTimeParseException`: 날짜/시간 파싱 실패 시 발생하는 예외입니다.

### 6.5 시간대 처리

```java
// 시간대 정보
ZoneId seoulZone = ZoneId.of("Asia/Seoul");
ZoneId utcZone = ZoneId.of("UTC");
ZoneId systemZone = ZoneId.systemDefault();

// 시간대별 시간 생성
ZonedDateTime seoulTime = ZonedDateTime.now(seoulZone);
ZonedDateTime utcTime = ZonedDateTime.now(utcZone);

// 시간대 변환
ZonedDateTime convertedTime = seoulTime.withZoneSameInstant(utcZone);

// Instant와 ZonedDateTime 변환
Instant instant = Instant.now();
ZonedDateTime fromInstant = instant.atZone(seoulZone);
Instant backToInstant = seoulTime.toInstant();

// 실무 예시: 전 세계 시간 표시
public static void showWorldTimes() {
    Instant now = Instant.now();
    String[] timeZones = {"America/New_York", "Europe/London", "Asia/Tokyo", "Asia/Seoul"};

    for (String tz : timeZones) {
        ZonedDateTime local = now.atZone(ZoneId.of(tz));
        System.out.printf("%s: %s%n", tz, local.format(DateTimeFormatter.ofPattern("HH:mm")));
    }
}
```

**설명:**
- `ZoneId`: 시간대를 나타내는 클래스입니다. IANA Time Zone Database의 ID를 사용합니다.
- `ZoneId.of()`: 특정 시간대 ID로 ZoneId 객체를 생성합니다.
- `systemDefault()`: 시스템의 기본 시간대를 반환합니다.
- `ZonedDateTime.now()`: 특정 시간대의 현재 시간을 반환합니다.
- `withZoneSameInstant()`: 같은 시점을 다른 시간대로 표현합니다.
- `Instant.atZone()`: UTC 시점을 특정 시간대의 시간으로 변환합니다.
- `toInstant()`: ZonedDateTime을 UTC 기준의 Instant로 변환합니다.
- 실무에서는 서버 시간을 UTC로 저장하고, 클라이언트에서 로컬 시간대로 변환하는 패턴을 주로 사용합니다.

---

## 7. 파일 I/O 심화

### 7.1 NIO.2 (New I/O) API

```java
import java.nio.file.*;
import java.nio.charset.StandardCharsets;

// Path 객체 생성
Path path = Paths.get("data", "sample.txt");
Path absolutePath = path.toAbsolutePath();
Path parentPath = path.getParent();
Path fileName = path.getFileName();

// 파일 존재 확인과 속성
boolean exists = Files.exists(path);
boolean isDirectory = Files.isDirectory(path);
boolean isReadable = Files.isReadable(path);
boolean isWritable = Files.isWritable(path);
long fileSize = Files.size(path);
```

**설명:**
- `NIO.2 (New I/O 2)`: Java 7에서 도입된 새로운 파일 시스템 API입니다.
- `Path`: 파일이나 디렉토리의 경로를 나타내는 인터페이스입니다.
- `Paths.get()`: 경로 문자열로부터 Path 객체를 생성합니다. 여러 매개변수는 자동으로 경로 구분자로 연결됩니다.
- `toAbsolutePath()`: 상대 경로를 절대 경로로 변환합니다.
- `getParent()`: 부모 디렉토리의 Path를 반환합니다.
- `getFileName()`: 파일 이름 부분의 Path를 반환합니다.
- `Files`: Path를 사용하여 파일 작업을 수행하는 유틸리티 클래스입니다.
- `exists()`: 파일이나 디렉토리가 존재하는지 확인합니다.
- `isDirectory()`: 디렉토리인지 확인합니다.
- `isReadable()`, `isWritable()`: 읽기/쓰기 권한을 확인합니다.
- `size()`: 파일 크기를 바이트 단위로 반환합니다.

### 7.2 파일 읽기와 쓰기

```java
// 전체 파일을 한 번에 읽기
List<String> lines = Files.readAllLines(path, StandardCharsets.UTF_8);
String content = Files.readString(path);  // Java 11+
byte[] bytes = Files.readAllBytes(path);

// 대용량 파일을 스트림으로 읽기
try (Stream<String> lineStream = Files.lines(path)) {
        lineStream
        .filter(line -> line.contains("Java"))
        .forEach(System.out::println);
}

// 파일 쓰기
List<String> outputLines = Arrays.asList("Line 1", "Line 2", "Line 3");
Files.write(path, outputLines, StandardCharsets.UTF_8);
Files.writeString(path, "Single line content");  // Java 11+

// 추가 모드로 쓰기
Files.write(path, "추가 내용".getBytes(), StandardOpenOption.APPEND);
```

**설명:**
- `readAllLines()`: 파일의 모든 라인을 List<String>으로 읽습니다. 작은 파일에 적합합니다.
- `readString()`: 파일 전체를 하나의 문자열로 읽습니다 (Java 11+).
- `readAllBytes()`: 파일의 모든 바이트를 바이트 배열로 읽습니다.
- `Files.lines()`: 파일을 Stream<String>으로 읽습니다. 대용량 파일에 적합하며, try-with-resources로 자동 close됩니다.
- `write()`: List나 바이트 배열을 파일에 씁니다.
- `writeString()`: 문자열을 파일에 씁니다 (Java 11+).
- `StandardOpenOption.APPEND`: 파일 끝에 내용을 추가하는 옵션입니다.
- Stream을 사용한 읽기는 메모리 효율적이며, 파일을 한 번에 메모리에 로드하지 않습니다.

### 7.3 디렉토리 처리와 파일 탐색

```java
// 디렉토리 생성
Path newDir = Paths.get("new_directory");
Files.createDirectory(newDir);                    // 단일 디렉토리
Files.createDirectories(Paths.get("a/b/c"));     // 중간 디렉토리도 함께 생성

// 디렉토리 내용 나열
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(newDir)) {
        for (Path entry : stream) {
        System.out.println(entry.getFileName());
        }
        }

// 재귀적 파일 탐색
        try (Stream<Path> paths = Files.walk(Paths.get("."))) {
        paths
        .filter(Files::isRegularFile)
        .filter(path -> path.toString().endsWith(".java"))
        .forEach(System.out::println);
}

// 파일 찾기
        try (Stream<Path> paths = Files.find(Paths.get("."),
        Integer.MAX_VALUE,
        (path, attrs) -> attrs.isRegularFile()
                && path.toString().endsWith(".txt"))) {
        paths.forEach(System.out::println);
}
```

**설명:**
- `createDirectory()`: 단일 디렉토리를 생성합니다. 부모 디렉토리가 없으면 예외가 발생합니다.
- `createDirectories()`: 필요한 모든 부모 디렉토리를 포함하여 디렉토리를 생성합니다.
- `DirectoryStream`: 디렉토리의 내용을 반복하는 인터페이스입니다. AutoCloseable을 구현합니다.
- `Files.walk()`: 디렉토리 트리를 재귀적으로 탐색하는 Stream을 반환합니다.
- `isRegularFile()`: 일반 파일(디렉토리나 특수 파일이 아닌)인지 확인합니다.
- `Files.find()`: 지정된 조건에 맞는 파일들을 찾는 Stream을 반환합니다.
- `Integer.MAX_VALUE`: 탐색 깊이를 최대로 설정합니다.
- 람다 표현식 `(path, attrs)`: 경로와 파일 속성을 매개변수로 받는 조건 함수입니다.

### 7.4 고급 I/O 작업

```java
// 파일 복사와 이동
Path source = Paths.get("source.txt");
Path target = Paths.get("target.txt");

Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);
Files.move(source, Paths.get("moved.txt"), StandardCopyOption.REPLACE_EXISTING);

// 심볼릭 링크
Path link = Paths.get("link.txt");
Files.createSymbolicLink(link, target);

// 파일 속성 읽기
BasicFileAttributes attrs = Files.readAttributes(path, BasicFileAttributes.class);
System.out.println("생성 시간: " + attrs.creationTime());
        System.out.println("마지막 수정: " + attrs.lastModifiedTime());
        System.out.println("파일 크기: " + attrs.size());

// 파일 속성 수정
FileTime newTime = FileTime.fromMillis(System.currentTimeMillis());
Files.setLastModifiedTime(path, newTime);
```

**설명:**
- `Files.copy()`: 파일을 복사합니다. 옵션으로 동작을 제어할 수 있습니다.
- `Files.move()`: 파일을 이동하거나 이름을 변경합니다.
- `StandardCopyOption.REPLACE_EXISTING`: 대상 파일이 이미 존재하면 덮어씁니다.
- `createSymbolicLink()`: 심볼릭 링크를 생성합니다 (Unix 계열 시스템에서 주로 사용).
- `BasicFileAttributes`: 파일의 기본 속성 정보를 담는 인터페이스입니다.
- `readAttributes()`: 파일의 속성 정보를 읽어옵니다.
- `creationTime()`: 파일 생성 시간을 반환합니다.
- `lastModifiedTime()`: 파일 마지막 수정 시간을 반환합니다.
- `FileTime`: 파일 시스템의 시간을 나타내는 클래스입니다.
- `setLastModifiedTime()`: 파일의 마지막 수정 시간을 변경합니다.

---

## 8. 스레드와 동시성

### 8.1 Thread 클래스와 Runnable

```java
// Thread 생성 방법들
Thread thread1 = new Thread(() -> {
    System.out.println("Lambda로 생성된 스레드");
});

Thread thread2 = new Thread(new Runnable() {
    @Override
    public void run() {
        System.out.println("익명 클래스로 생성된 스레드");
    }
});

// Thread 생명주기 관리
thread1.start();                    // 스레드 시작
thread1.join();                     // 스레드 완료 대기
thread1.interrupt();                // 스레드 중단 요청
boolean isAlive = thread1.isAlive(); // 실행 중인지 확인

// 스레드 우선순위
thread1.setPriority(Thread.MAX_PRIORITY);
int priority = thread1.getPriority();
```

**설명:**
- `Thread`: Java에서 스레드를 생성하고 관리하는 기본 클래스입니다.
- `Runnable`: 스레드가 실행할 작업을 정의하는 함수형 인터페이스입니다.
- Lambda 표현식과 익명 클래스 모두 Runnable 구현체를 생성하는 방법입니다.
- `start()`: 스레드를 시작합니다. run() 메서드를 직접 호출하지 않고 반드시 start()를 사용해야 합니다.
- `join()`: 현재 스레드가 대상 스레드의 완료를 기다리게 합니다.
- `interrupt()`: 스레드에게 중단 신호를 보냅니다. InterruptedException을 발생시킬 수 있습니다.
- `isAlive()`: 스레드가 아직 실행 중인지 확인합니다.
- `setPriority()`: 스레드의 우선순위를 설정합니다 (1-10, 기본값 5).
- `MAX_PRIORITY`: 최고 우선순위 상수 (10)입니다.

### 8.2 ExecutorService와 스레드 풀

```java
// 다양한 스레드 풀 생성
ExecutorService fixedPool = Executors.newFixedThreadPool(4);
ExecutorService cachedPool = Executors.newCachedThreadPool();
ExecutorService singlePool = Executors.newSingleThreadExecutor();
ScheduledExecutorService scheduledPool = Executors.newScheduledThreadPool(2);

// 작업 제출과 결과 처리
Future<String> future = fixedPool.submit(() -> {
    Thread.sleep(1000);
    return "작업 완료";
});

try {
String result = future.get(2, TimeUnit.SECONDS);  // 타임아웃 설정
    System.out.println(result);
} catch (TimeoutException e) {
        future.cancel(true);  // 작업 취소
}

// 여러 작업 동시 실행
List<Callable<Integer>> tasks = Arrays.asList(
        () -> { Thread.sleep(1000); return 1; },
        () -> { Thread.sleep(2000); return 2; },
        () -> { Thread.sleep(1500); return 3; }
);

List<Future<Integer>> futures = fixedPool.invokeAll(tasks);
Integer firstResult = fixedPool.invokeAny(tasks);  // 가장 빨리 완료된 결과

// 예약 작업
scheduledPool.schedule(() -> System.out.println("1초 후 실행"), 1, TimeUnit.SECONDS);
        scheduledPool.scheduleAtFixedRate(() -> System.out.println("주기적 실행"), 
                                  0, 5, TimeUnit.SECONDS);
```

**설명:**
- `ExecutorService`: 스레드 풀을 관리하고 작업을 실행하는 인터페이스입니다.
- `newFixedThreadPool()`: 고정 크기의 스레드 풀을 생성합니다.
- `newCachedThreadPool()`: 필요에 따라 스레드를 생성하고 재사용하는 풀입니다.
- `newSingleThreadExecutor()`: 단일 스레드로 작업을 순차 실행하는 풀입니다.
- `newScheduledThreadPool()`: 예약된 작업과 주기적 작업을 실행할 수 있는 풀입니다.
- `submit()`: 작업을 제출하고 Future 객체를 반환합니다.
- `Future`: 비동기 작업의 결과를 나타내는 인터페이스입니다.
- `get(timeout, unit)`: 지정된 시간 내에 결과를 기다립니다.
- `cancel()`: 작업을 취소합니다.
- `Callable`: Runnable과 유사하지만 결과를 반환하고 예외를 던질 수 있습니다.
- `invokeAll()`: 모든 작업을 실행하고 모든 결과를 기다립니다.
- `invokeAny()`: 작업들 중 가장 빨리 완료된 하나의 결과만 반환합니다.
- `schedule()`: 지연 후 한 번 실행합니다.
- `scheduleAtFixedRate()`: 일정한 주기로 반복 실행합니다.

### 8.3 동기화와 락

```java
// synchronized 블록
private final Object lock = new Object();
public void synchronizedMethod() {
    synchronized(lock) {
        // 동기화된 코드 블록
    }
}

// ReentrantLock 활용
private final ReentrantLock lock = new ReentrantLock();
public void lockMethod() {
    lock.lock();
    try {
        // 임계 영역
    } finally {
        lock.unlock();
    }
}

// ReadWriteLock으로 성능 최적화
private final ReadWriteLock rwLock = new ReentrantReadWriteLock();
private final Lock readLock = rwLock.readLock();
private final Lock writeLock = rwLock.writeLock();

public String read() {
    readLock.lock();
    try {
        return data;  // 여러 스레드가 동시에 읽기 가능
    } finally {
        readLock.unlock();
    }
}
```

**설명:**
- `synchronized`: Java의 기본 동기화 메커니즘으로, 한 번에 하나의 스레드만 임계 영역에 접근할 수 있게 합니다.
- 객체를 락으로 사용하여 동기화할 수 있습니다.
- `ReentrantLock`: 명시적인 락 객체로, synchronized보다 더 세밀한 제어가 가능합니다.
- `lock()`: 락을 획득합니다. 다른 스레드가 이미 락을 가지고 있으면 대기합니다.
- `unlock()`: 락을 해제합니다. finally 블록에서 호출하여 반드시 해제되도록 해야 합니다.
- `ReentrantReadWriteLock`: 읽기와 쓰기를 분리한 락입니다.
- `readLock()`: 읽기 전용 락으로, 여러 스레드가 동시에 읽기 작업을 수행할 수 있습니다.
- `writeLock()`: 쓰기 전용 락으로, 한 번에 하나의 스레드만 쓰기 작업을 수행할 수 있습니다.
- 읽기 작업이 많은 상황에서 성능 향상을 제공합니다.

---

## 9. 내부 구조와 성능 이해

### 9.1 String의 메모리 최적화

```java
// String Pool 동작 원리
String s1 = "Hello";                // Heap의 String Pool 영역
String s2 = "Hello";                // 같은 객체 참조
String s3 = new String("Hello");    // Heap의 일반 영역에 새 객체
String s4 = s3.intern();            // String Pool로 이동 (s1과 같은 참조)

// StringBuilder vs StringBuffer 성능
public static String concatenateStrings(List<String> strings) {
    StringBuilder sb = new StringBuilder(strings.size() * 16); // 적절한 초기 용량
    for (String str : strings) {
        sb.append(str);
    }
    return sb.toString();
}

// String 연산 시 메모리 누수 방지
// 잘못된 예시
String result = "";
for (int i = 0; i < 1000; i++) {
result += "a";  // 매번 새 String 객체 생성 (O(n²) 복잡도)
        }

// 올바른 예시
StringBuilder sb = new StringBuilder(1000);
for (int i = 0; i < 1000; i++) {
        sb.append("a");  // O(n) 복잡도
}
String result = sb.toString();
```

**설명:**
- `String Pool`: JVM 힙 메모리의 특별한 영역으로, 문자열 리터럴의 중복을 방지합니다.
- 리터럴로 생성된 문자열들은 같은 내용이면 같은 객체를 참조합니다.
- `new String()`: 항상 새로운 객체를 힙에 생성합니다.
- `intern()`: 문자열을 String Pool로 이동시켜 메모리를 절약합니다.
- `StringBuilder`: 가변 길이 문자열 버퍼로, 단일 스레드에서 사용합니다.
- 초기 용량을 적절히 설정하면 내부 배열의 재할당을 줄여 성능을 향상시킬 수 있습니다.
- 문자열 연결 시 + 연산자를 반복 사용하면 매번 새 String 객체가 생성되어 성능이 크게 저하됩니다.
- StringBuilder를 사용하면 내부 버퍼에서 문자열을 조작하므로 훨씬 효율적입니다.

### 9.2 Collection의 성능 특성

```java
// ArrayList vs LinkedList 성능 분석
public class PerformanceComparison {
    public static void arrayListVsLinkedList() {
        List<Integer> arrayList = new ArrayList<>();
        List<Integer> linkedList = new LinkedList<>();

        // 순차 추가: ArrayList 우세 (동적 배열 확장)
        // 중간 삽입: LinkedList 우세 (노드 연결만 변경)
        // 인덱스 접근: ArrayList 압도적 우세 (O(1) vs O(n))
        // 메모리 사용량: ArrayList 우세 (연속 메모리)
    }

    // HashMap 로드팩터와 성능
    public static void hashMapOptimization() {
        // 초기 용량 설정으로 리해싱 방지
        Map<String, Integer> map = new HashMap<>(1000, 0.75f);

        // 해시 충돌 최소화를 위한 좋은 hashCode 구현 필요
    }
}
```

**설명:**
- `ArrayList`: 내부적으로 배열을 사용하므로 인덱스 기반 접근이 O(1)로 매우 빠릅니다.
- 순차 추가는 보통 O(1)이지만, 배열이 가득 차면 새 배열을 할당하고 복사하므로 간헐적으로 O(n)입니다.
- `LinkedList`: 노드 기반 구조로 인덱스 접근 시 O(n)의 순차 탐색이 필요합니다.
- 중간 위치 삽입/삭제는 노드의 연결만 변경하면 되므로 O(1)입니다.
- `HashMap`: 기본 로드팩터는 0.75로, 테이블이 75% 차면 크기를 두 배로 늘립니다.
- 초기 용량을 적절히 설정하면 리해싱(rehashing)을 방지하여 성능을 향상시킬 수 있습니다.
- 좋은 hashCode() 구현은 해시 충돌을 줄여 성능을 크게 향상시킵니다.

### 9.3 가비지 컬렉션과 메모리 관리

```java
// 메모리 사용량 모니터링
MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();

System.out.println("사용된 메모리: " + heapUsage.getUsed() / 1024 / 1024 + " MB");
        System.out.println("최대 메모리: " + heapUsage.getMax() / 1024 / 1024 + " MB");

// 메모리 효율적인 코드 작성
public class MemoryEfficient {
    // 대용량 데이터 처리 시 스트림 활용
    public static long processLargeFile(Path filePath) {
        try (Stream<String> lines = Files.lines(filePath)) {
            return lines
                    .filter(line -> line.contains("ERROR"))
                    .count();  // 전체 파일을 메모리에 로드하지 않음
        } catch (IOException e) {
            return 0;
        }
    }

    // 객체 재사용으로 GC 압박 감소
    private static final StringBuilder REUSABLE_BUILDER = new StringBuilder();

    public static synchronized String buildString(String... parts) {
        REUSABLE_BUILDER.setLength(0);  // 기존 내용 제거
        for (String part : parts) {
            REUSABLE_BUILDER.append(part);
        }
        return REUSABLE_BUILDER.toString();
    }
}
```

**설명:**
- `MemoryMXBean`: JVM의 메모리 사용량을 모니터링할 수 있는 관리 인터페이스입니다.
- `getHeapMemoryUsage()`: 힙 메모리의 사용 정보를 반환합니다.
- `getUsed()`: 현재 사용 중인 메모리양을 바이트 단위로 반환합니다.
- `getMax()`: 최대 사용 가능한 메모리양을 바이트 단위로 반환합니다.
- 스트림 처리: 파일을 한 번에 메모리에 로드하지 않고 라인별로 처리하여 메모리 효율성을 높입니다.
- 객체 재사용: 임시 객체 생성을 줄여 가비지 컬렉션의 부담을 덜어줍니다.
- `setLength(0)`: StringBuilder의 내용을 지우되 내부 버퍼는 유지하여 재사용합니다.
- `synchronized`: 멀티스레드 환경에서 StringBuilder 재사용 시 동기화가 필요합니다.

---

## 10. 고급 유틸리티 클래스들

### 10.1 Objects 클래스 (Java 7+)

```java
// Null-safe 연산들
String a = "Hello";
String b = null;

boolean equals = Objects.equals(a, b);           // false (null 안전)
int hashCode = Objects.hash(a, b);               // 복합 해시코드
String string = Objects.toString(b, "default"); // null일 때 기본값

// 유효성 검사
String validated = Objects.requireNonNull(a, "a는 null일 수 없습니다");
Objects.requireNonNull(a);  // null이면 NullPointerException

// 비교
int comparison = Objects.compare(a, b, String.CASE_INSENSITIVE_ORDER);
```

**설명:**
- `Objects`: Java 7에서 도입된 유틸리티 클래스로, null-safe한 연산들을 제공합니다.
- `Objects.equals()`: 두 객체가 null이어도 안전하게 비교합니다. 둘 다 null이면 true를 반환합니다.
- `Objects.hash()`: 여러 객체로부터 해시코드를 생성합니다. null 값도 안전하게 처리합니다.
- `Objects.toString()`: 객체가 null이면 지정된 기본값을 반환합니다.
- `Objects.requireNonNull()`: 객체가 null이면 NullPointerException을 던집니다. 사용자 정의 메시지도 제공할 수 있습니다.
- `Objects.compare()`: Comparator를 사용하여 두 객체를 null-safe하게 비교합니다.
- 이러한 메서드들은 방어적 프로그래밍에서 null 체크를 간편하게 해줍니다.

### 10.2 Arrays 클래스 고급 활용

```java
int[] numbers = {3, 1, 4, 1, 5, 9, 2, 6};

// 정렬과 검색
Arrays.sort(numbers);                           // 오름차순 정렬
int index = Arrays.binarySearch(numbers, 5);    // 이진 검색 (정렬된 배열 필요)

// 배열 비교
int[] other = {1, 1, 2, 3, 4, 5, 6, 9};
boolean equal = Arrays.equals(numbers, other);  // 내용 비교
int comparison = Arrays.compare(numbers, other); // 사전식 비교

// 배열 복사
int[] copied = Arrays.copyOf(numbers, 10);      // 크기 10으로 복사 (부족하면 0 채움)
int[] range = Arrays.copyOfRange(numbers, 2, 6); // 부분 복사

// 배열 채우기
int[] filled = new int[10];
Arrays.fill(filled, 42);                        // 모든 요소를 42로
Arrays.fill(filled, 2, 5, 99);                  // 인덱스 2~4만 99로

// 다차원 배열
int[][] matrix = {{1, 2}, {3, 4}};
String deepString = Arrays.deepToString(matrix); // "[[1, 2], [3, 4]]"
boolean deepEqual = Arrays.deepEquals(matrix, matrix);
```

**설명:**
- `Arrays`: 배열 조작을 위한 유틸리티 클래스입니다.
- `sort()`: 배열을 오름차순으로 정렬합니다. 기본 타입은 dual-pivot quicksort, 객체 타입은 TimSort를 사용합니다.
- `binarySearch()`: 정렬된 배열에서 이진 검색을 수행합니다. 찾으면 인덱스를, 못 찾으면 음수를 반환합니다.
- `equals()`: 두 배열의 내용을 비교합니다.
- `compare()`: 두 배열을 사전식 순서로 비교합니다.
- `copyOf()`: 배열을 복사하되 새로운 크기를 지정할 수 있습니다.
- `copyOfRange()`: 배열의 특정 범위만 복사합니다.
- `fill()`: 배열의 모든 요소나 특정 범위를 지정된 값으로 채웁니다.
- `deepToString()`: 다차원 배열을 문자열로 변환합니다.
- `deepEquals()`: 다차원 배열의 내용을 깊이 비교합니다.

### 10.3 Collections 클래스 완전 활용

```java
List<Integer> list = new ArrayList<>(Arrays.asList(3, 1, 4, 1, 5));

// 정렬과 셔플
Collections.sort(list);                         // 오름차순
Collections.sort(list, Collections.reverseOrder()); // 내림차순
        Collections.shuffle(list);                      // 무작위 섞기
Collections.reverse(list);                      // 순서 뒤집기

// 검색과 치환
int index = Collections.binarySearch(list, 4);  // 이진 검색
int frequency = Collections.frequency(list, 1); // 요소 빈도
Collections.replaceAll(list, 1, 10);           // 모든 1을 10으로 교체

// 극값 찾기
Integer min = Collections.min(list);
Integer max = Collections.max(list);
Integer maxCustom = Collections.max(list, (a, b) -> Integer.compare(a % 10, b % 10));

// 회전과 스왑
Collections.rotate(list, 2);                   // 오른쪽으로 2칸 회전
Collections.swap(list, 0, list.size() - 1);   // 첫 번째와 마지막 요소 교환

// 불변 컬렉션 생성
List<String> immutableList = Collections.unmodifiableList(Arrays.asList("A", "B", "C"));
Set<String> singletonSet = Collections.singleton("Only");
Map<String, Integer> singletonMap = Collections.singletonMap("key", 42);

// 동기화된 컬렉션
List<String> syncList = Collections.synchronizedList(new ArrayList<>());
Map<String, Integer> syncMap = Collections.synchronizedMap(new HashMap<>());
```

**설명:**
- `Collections`: 컬렉션 조작을 위한 유틸리티 클래스입니다.
- `sort()`: 리스트를 정렬합니다. Comparator를 제공할 수 있습니다.
- `reverseOrder()`: 역순 Comparator를 반환합니다.
- `shuffle()`: 리스트의 요소들을 무작위로 섞습니다.
- `reverse()`: 리스트의 요소 순서를 뒤집습니다.
- `binarySearch()`: 정렬된 리스트에서 이진 검색을 수행합니다.
- `frequency()`: 특정 요소가 나타나는 빈도를 계산합니다.
- `replaceAll()`: 특정 값을 모두 다른 값으로 교체합니다.
- `min()`, `max()`: 최솟값과 최댓값을 찾습니다. 사용자 정의 Comparator도 사용할 수 있습니다.
- `rotate()`: 리스트의 요소들을 순환 이동시킵니다.
- `swap()`: 두 위치의 요소를 교환합니다.
- `unmodifiableList()`: 수정 불가능한 리스트 뷰를 반환합니다.
- `singleton()`: 단일 요소만 포함하는 불변 Set을 반환합니다.
- `singletonMap()`: 단일 엔트리만 포함하는 불변 Map을 반환합니다.
- `synchronizedList()`, `synchronizedMap()`: 동기화된 컬렉션 래퍼를 반환합니다.

---

## 11. 정규표현식 (Pattern & Matcher)

### 11.1 Pattern 클래스 심화

```java
// Pattern 컴파일과 재사용
Pattern emailPattern = Pattern.compile(
        "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$",
        Pattern.CASE_INSENSITIVE
);

// 매칭 확인
boolean isValidEmail = emailPattern.matcher("user@example.com").matches();

// 그룹 매칭
Pattern phonePattern = Pattern.compile("(\\d{3})-(\\d{4})-(\\d{4})");
Matcher phoneMatcher = phonePattern.matcher("010-1234-5678");

if (phoneMatcher.matches()) {
String areaCode = phoneMatcher.group(1);    // "010"
String firstPart = phoneMatcher.group(2);   // "1234"
String secondPart = phoneMatcher.group(3);  // "5678"
}

// 모든 매칭 찾기
String text = "이메일: user1@test.com, user2@example.org";
Matcher emailMatcher = emailPattern.matcher(text);
while (emailMatcher.find()) {
        System.out.println("찾은 이메일: " + emailMatcher.group());
        System.out.println("위치: " + emailMatcher.start() + "-" + emailMatcher.end());
        }

// 치환 작업
String masked = phoneMatcher.replaceAll("$1-****-$3");  // 010-****-5678
String allReplaced = emailMatcher.replaceAll("[이메일]"); // 모든 이메일을 [이메일]로 치환
```

**설명:**
- `Pattern`: 정규표현식을 컴파일하여 재사용 가능한 패턴 객체를 생성합니다.
- `Pattern.compile()`: 정규표현식 문자열을 Pattern 객체로 컴파일합니다. 플래그를 지정할 수 있습니다.
- `CASE_INSENSITIVE`: 대소문자를 구분하지 않는 매칭을 수행합니다.
- `matcher()`: 주어진 문자열에 대한 Matcher 객체를 생성합니다.
- `matches()`: 전체 문자열이 패턴과 일치하는지 확인합니다.
- `Matcher`: 패턴 매칭 작업을 수행하는 클래스입니다.
- `group()`: 매칭된 전체 문자열 또는 특정 그룹을 반환합니다.
- `group(n)`: n번째 캡처 그룹의 내용을 반환합니다. 괄호로 묶인 부분이 그룹이 됩니다.
- `find()`: 다음 매칭을 찾습니다. 여러 매칭을 찾을 때 사용합니다.
- `start()`, `end()`: 매칭된 부분의 시작과 끝 인덱스를 반환합니다.
- `replaceAll()`: 모든 매칭을 대체 문자열로 치환합니다. `$1`, `$3`은 그룹 참조입니다.

## 12. Java 9+ 추가 기능들

### 12.1 모듈 시스템 (Java 9)

```java
// module-info.java 예시
module com.example.myapp {
    requires java.base;          // 암시적으로 항상 포함
    requires java.logging;       // 로깅 모듈 의존성
    exports com.example.api;     // 외부에 노출할 패키지
    provides com.example.Service with com.example.ServiceImpl; // 서비스 제공
}
```

**설명:**
- `module-info.java`: 모듈 시스템의 핵심 파일로, 모듈의 의존성과 공개 API를 정의합니다.
- `module`: 모듈을 선언하는 키워드입니다.
- `requires`: 다른 모듈에 대한 의존성을 선언합니다.
- `java.base`: 모든 모듈이 암시적으로 의존하는 기본 모듈입니다.
- `exports`: 다른 모듈에서 사용할 수 있도록 패키지를 공개합니다.
- `provides ... with`: 서비스 제공자를 등록합니다.
- 모듈 시스템은 패키지 간의 강한 캡슐화와 명시적 의존성 관리를 제공합니다.

### 12.2 컬렉션 팩토리 메서드 (Java 9)

```java
// 불변 컬렉션 생성
List<String> immutableList = List.of("A", "B", "C");
Set<Integer> immutableSet = Set.of(1, 2, 3);
Map<String, Integer> immutableMap = Map.of(
        "apple", 1,
        "banana", 2,
        "cherry", 3
);

// 주의: null 값 불허, 중복 키 불허 (Set, Map)
// 수정 시도 시 UnsupportedOperationException 발생
```

**설명:**
- `List.of()`: 불변 리스트를 생성하는 팩토리 메서드입니다.
- `Set.of()`: 불변 집합을 생성합니다. 중복 요소가 있으면 IllegalArgumentException이 발생합니다.
- `Map.of()`: 불변 맵을 생성합니다. 키-값 쌍을 교대로 나열합니다.
- 생성된 컬렉션들은 모두 불변이므로 add, remove 등의 수정 작업 시 예외가 발생합니다.
- null 값을 허용하지 않으며, null을 추가하려고 하면 NullPointerException이 발생합니다.
- 기존의 Collections.unmodifiableXxx()보다 간결하고 성능이 좋습니다.

### 12.3 var 키워드 (Java 10)

```java
// 지역 변수 타입 추론
var message = "Hello World";              // String 타입으로 추론
var numbers = Arrays.asList(1, 2, 3);     // List<Integer>로 추론
var map = new HashMap<String, Integer>(); // HashMap<String, Integer>로 추론

// 제한사항
// var x;                    // 컴파일 오류: 초기화 필요
// var x = null;             // 컴파일 오류: 타입 추론 불가
// private var field;        // 컴파일 오류: 지역 변수만 가능
```

**설명:**
- `var`: Java 10에서 도입된 지역 변수 타입 추론 키워드입니다.
- 컴파일러가 초기화 표현식을 보고 변수의 타입을 자동으로 추론합니다.
- 코드를 더 간결하게 만들어주지만, 타입이 명확하지 않을 때는 사용을 피해야 합니다.
- 지역 변수(메서드 내부, for 루프 등)에서만 사용할 수 있습니다.
- 필드, 매개변수, 메서드 반환 타입에는 사용할 수 없습니다.
- 반드시 초기화와 함께 선언해야 하며, null로는 초기화할 수 없습니다.

### 12.4 Switch 표현식 (Java 12-14)

```java
// 기존 switch 문
String dayType;
switch (dayOfWeek) {
        case MONDAY:
        case TUESDAY:
        case WEDNESDAY:
        case THURSDAY:
        case FRIDAY:
dayType = "Weekday";
        break;
        case SATURDAY:
        case SUNDAY:
dayType = "Weekend";
        break;
default:
dayType = "Unknown";
        }

// 새로운 switch 표현식 (Java 14+)
String dayType = switch (dayOfWeek) {
    case MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY -> "Weekday";
    case SATURDAY, SUNDAY -> "Weekend";
    default -> "Unknown";
};

// yield를 사용한 복잡한 로직
String result = switch (score) {
    case 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100 -> "A";
    case 80, 81, 82, 83, 84, 85, 86, 87, 88, 89 -> "B";
    default -> {
        String grade = score >= 70 ? "C" : "F";
        yield "Grade: " + grade;
    }
};
```

**설명:**
- `switch 표현식`: Java 12-14에서 단계적으로 도입된 새로운 switch 문법입니다.
- `->` 화살표 구문: 전통적인 case 레이블 대신 사용하며, break가 불필요합니다.
- 여러 case 값을 쉼표로 구분하여 하나의 결과에 매핑할 수 있습니다.
- switch 표현식은 값을 반환하므로 변수에 직접 할당할 수 있습니다.
- `yield`: 복잡한 로직이 필요한 경우 블록 내에서 값을 반환할 때 사용합니다.
- 모든 가능한 케이스를 다루어야 하므로 exhaustiveness 검사가 이루어집니다.
- 기존 switch 문보다 간결하고 오류가 적은 코드를 작성할 수 있습니다.

### 12.5 Record 클래스 (Java 14+)

```java
// 전통적인 데이터 클래스
public class PersonOld {
    private final String name;
    private final int age;

    public PersonOld(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // getter, equals, hashCode, toString 메서드들...
}

// Record로 간단하게
public record Person(String name, int age) {
    // 자동으로 생성됨:
    // - 생성자
    // - getter 메서드 (name(), age())
    // - equals(), hashCode(), toString()

    // 커스텀 검증
    public Person {
        if (age < 0) {
            throw new IllegalArgumentException("나이는 음수일 수 없습니다");
        }
    }

    // 추가 메서드 정의 가능
    public boolean isAdult() {
        return age >= 18;
    }
}

// 사용 예시
Person person = new Person("Alice", 25);
System.out.println(person.name());          // "Alice"
        System.out.println(person.age());           // 25
        System.out.println(person.isAdult());       // true
```

**설명:**
- `record`: Java 14에서 preview로 도입되고 Java 16에서 정식으로 추가된 데이터 클래스입니다.
- 불변 데이터를 담는 클래스를 간단하게 정의할 수 있습니다.
- 컴파일러가 자동으로 다음을 생성합니다: 생성자, getter 메서드, equals(), hashCode(), toString()
- getter 메서드는 getXxx() 형태가 아닌 필드명 그대로입니다 (name(), age()).
- 컴팩트 생성자: `public Person { ... }` 형태로 검증 로직을 추가할 수 있습니다.
- 추가 메서드나 정적 메서드를 정의할 수 있습니다.
- Record는 final 클래스이므로 상속할 수 없지만, 인터페이스는 구현할 수 있습니다.
- 모든 필드가 자동으로 final이 되어 불변성이 보장됩니다.

### 12.6 텍스트 블록 (Java 15+)

```java
// 기존 방식
String json = "{\n" +
        "  \"name\": \"John\",\n" +
        "  \"age\": 30,\n" +
        "  \"city\": \"Seoul\"\n" +
        "}";

// 텍스트 블록 방식
String json = """
        {
          "name": "John",
          "age": 30,
          "city": "Seoul"
        }
        """;

// SQL 쿼리 예시
String sql = """
        SELECT u.name, u.email, p.title
        FROM users u
        JOIN posts p ON u.id = p.user_id
        WHERE u.active = true
        ORDER BY u.name
        """;

// 인덴테이션 처리
String formatted = """
        Line 1
            Line 2 (indented)
        Line 3
        """.stripIndent();  // 공통 인덴테이션 제거
```

**설명:**
- `텍스트 블록`: Java 15에서 정식 도입된 멀티라인 문자열 리터럴입니다.
- `"""` (세 개의 따옴표)로 시작하고 끝납니다.
- 문자열 연결이나 이스케이프 시퀀스 없이 여러 줄 텍스트를 작성할 수 있습니다.
- JSON, SQL, HTML 등의 멀티라인 텍스트를 작성할 때 매우 유용합니다.
- 인덴테이션은 자동으로 처리되며, 공통된 들여쓰기는 제거됩니다.
- `stripIndent()`: 각 라인의 공통 선행 공백을 제거합니다.
- 텍스트 블록 내에서도 이스케이프 시퀀스를 사용할 수 있습니다.

### 12.7 Pattern Matching (Java 17+)

```java
// instanceof 패턴 매칭
public static String processObject(Object obj) {
    if (obj instanceof String s) {
        return "String length: " + s.length();  // 자동 캐스팅
    } else if (obj instanceof Integer i) {
        return "Integer value: " + i;
    } else if (obj instanceof List<?> list && !list.isEmpty()) {
        return "List size: " + list.size();
    }
    return "Unknown type";
}

// Switch에서 패턴 매칭 (Preview in Java 17+)
public static String describe(Object obj) {
    return switch (obj) {
        case null -> "null value";
        case String s when s.isEmpty() -> "empty string";
        case String s -> "string of length " + s.length();
        case Integer i when i > 0 -> "positive integer: " + i;
        case Integer i -> "non-positive integer: " + i;
        case List<?> list -> "list of size " + list.size();
        default -> "unknown object";
    };
}
```

**설명:**
- `Pattern Matching`: 객체의 타입과 구조를 패턴으로 매칭하여 처리하는 기능입니다.
- `instanceof 패턴 매칭`: instanceof 검사와 동시에 자동 캐스팅이 이루어집니다.
- 패턴 변수 `s`, `i`, `list`는 해당 블록 내에서 자동으로 적절한 타입으로 사용할 수 있습니다.
- 가드 조건 `&&`을 사용하여 추가 조건을 검사할 수 있습니다.
- `when` 키워드: switch 패턴 매칭에서 추가 조건을 지정합니다 (Java 17+ preview).
- 패턴 매칭은 코드의 가독성을 높이고 타입 안전성을 보장합니다.
- null 패턴을 명시적으로 처리할 수 있습니다.

---

## 13. 네트워킹과 HTTP 클라이언트

### 13.1 HTTP 클라이언트 (Java 11+)

```java
import java.net.http.*;
import java.net.URI;
import java.time.Duration;

// HTTP 클라이언트 생성
HttpClient client = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(10))
        .followRedirects(HttpClient.Redirect.NORMAL)
        .build();

// GET 요청
HttpRequest getRequest = HttpRequest.newBuilder()
        .uri(URI.create("https://api.example.com/users"))
        .header("Accept", "application/json")
        .timeout(Duration.ofSeconds(30))
        .GET()
        .build();

// 동기 요청
HttpResponse<String> response = client.send(getRequest,
        HttpResponse.BodyHandlers.ofString());

System.out.println("Status: " + response.statusCode());
        System.out.println("Body: " + response.body());

// 비동기 요청
CompletableFuture<HttpResponse<String>> futureResponse =
        client.sendAsync(getRequest, HttpResponse.BodyHandlers.ofString());

futureResponse.thenAccept(resp -> {
        System.out.println("Async response: " + resp.body());
        });

// POST 요청
String jsonBody = """
        {
            "name": "John Doe",
            "email": "john@example.com"
        }
        """;

HttpRequest postRequest = HttpRequest.newBuilder()
        .uri(URI.create("https://api.example.com/users"))
        .header("Content-Type", "application/json")
        .POST(HttpRequest.BodyPublishers.ofString(jsonBody))
        .build();
```

**설명:**
- `HttpClient`: Java 11에서 도입된 표준 HTTP 클라이언트입니다.
- `newBuilder()`: 빌더 패턴을 사용하여 클라이언트를 구성합니다.
- `connectTimeout()`: 연결 타임아웃을 설정합니다.
- `followRedirects()`: 리다이렉트 처리 방식을 설정합니다.
- `HttpRequest`: HTTP 요청을 나타내는 클래스입니다.
- `uri()`: 요청 URI를 설정합니다.
- `header()`: HTTP 헤더를 추가합니다.
- `timeout()`: 요청별 타임아웃을 설정합니다.
- `GET()`, `POST()`: HTTP 메서드를 설정합니다.
- `send()`: 동기적으로 요청을 전송하고 응답을 기다립니다.
- `sendAsync()`: 비동기적으로 요청을 전송하고 CompletableFuture를 반환합니다.
- `BodyHandlers.ofString()`: 응답 본문을 문자열로 처리합니다.
- `BodyPublishers.ofString()`: 요청 본문을 문자열로 설정합니다.

### 13.2 URL과 URI 처리

```java
import java.net.*;

// URL 파싱과 조작
URL url = new URL("https://example.com:8080/path/to/resource?param1=value1&param2=value2#section");

String protocol = url.getProtocol();    // "https"
String host = url.getHost();            // "example.com"
int port = url.getPort();               // 8080
String path = url.getPath();            // "/path/to/resource"
String query = url.getQuery();          // "param1=value1&param2=value2"
String fragment = url.getRef();         // "section"

// URI 빌딩 (Java 11+)
URI uri = URI.create("https://api.example.com")
        .resolve("/v1/users")
        .resolve("?page=1&size=10");

// URL 인코딩/디코딩
String encoded = URLEncoder.encode("Hello World!", StandardCharsets.UTF_8);
String decoded = URLDecoder.decode(encoded, StandardCharsets.UTF_8);
```

**설명:**
- `URL`: 인터넷 상의 리소스 위치를 나타내는 클래스입니다.
- `getProtocol()`: URL의 프로토콜 부분 (http, https, ftp 등)을 반환합니다.
- `getHost()`: 호스트 이름을 반환합니다.
- `getPort()`: 포트 번호를 반환합니다. 기본 포트면 -1을 반환합니다.
- `getPath()`: 경로 부분을 반환합니다.
- `getQuery()`: 쿼리 스트링 부분 (?param=value)을 반환합니다.
- `getRef()`: 프래그먼트 부분 (#section)을 반환합니다.
- `URI`: URL보다 일반적인 리소스 식별자입니다.
- `resolve()`: 상대 경로를 절대 경로로 해결합니다.
- `URLEncoder.encode()`: URL에 안전한 형태로 문자열을 인코딩합니다.
- `URLDecoder.decode()`: URL 인코딩된 문자열을 원래 형태로 디코딩합니다.

---

## 14. 리플렉션 (Reflection) API

### 14.1 클래스 정보 조회

```java
Class<?> clazz = String.class;
// 또는 Class.forName("java.lang.String");
// 또는 "hello".getClass();

// 클래스 정보
String className = clazz.getName();              // "java.lang.String"
String simpleName = clazz.getSimpleName();      // "String"
Package pkg = clazz.getPackage();               // java.lang 패키지
Class<?> superClass = clazz.getSuperclass();    // Object.class

// 구현된 인터페이스들
Class<?>[] interfaces = clazz.getInterfaces();
for (Class<?> iface : interfaces) {
        System.out.println("Interface: " + iface.getName());
        }

// 어노테이션 확인
boolean isDeprecated = clazz.isAnnotationPresent(Deprecated.class);
Annotation[] annotations = clazz.getAnnotations();
```

**설명:**
- `Class<?>`: 클래스의 메타데이터를 나타내는 객체입니다.
- `String.class`: 클래스 리터럴을 사용한 Class 객체 획득 방법입니다.
- `Class.forName()`: 클래스 이름으로 Class 객체를 동적으로 로드합니다.
- `getClass()`: 객체 인스턴스로부터 Class 객체를 얻습니다.
- `getName()`: 클래스의 완전한 이름 (패키지 포함)을 반환합니다.
- `getSimpleName()`: 패키지명을 제외한 간단한 클래스 이름을 반환합니다.
- `getPackage()`: 클래스가 속한 패키지 정보를 반환합니다.
- `getSuperclass()`: 부모 클래스의 Class 객체를 반환합니다.
- `getInterfaces()`: 구현한 모든 인터페이스의 Class 배열을 반환합니다.
- `isAnnotationPresent()`: 특정 어노테이션이 있는지 확인합니다.
- `getAnnotations()`: 클래스에 적용된 모든 어노테이션을 반환합니다.

### 14.2 필드와 메서드 조작

```java
// 필드 정보
Field[] fields = clazz.getDeclaredFields();
for (Field field : fields) {
        System.out.println("Field: " + field.getName() + ", Type: " + field.getType());

        // private 필드 접근
        field.setAccessible(true);
Object value = field.get(someObject);
    field.set(someObject, newValue);
}

// 메서드 정보
Method[] methods = clazz.getDeclaredMethods();
for (Method method : methods) {
        System.out.println("Method: " + method.getName());
        System.out.println("Return type: " + method.getReturnType());
        System.out.println("Parameters: " + Arrays.toString(method.getParameterTypes()));
        }

// 메서드 호출
Method lengthMethod = String.class.getMethod("length");
Integer length = (Integer) lengthMethod.invoke("Hello");  // 5

// 생성자 사용
Constructor<?> constructor = String.class.getConstructor(String.class);
String newString = (String) constructor.newInstance("Hello");
```

**설명:**
- `Field`: 클래스의 필드(멤버 변수)를 나타내는 클래스입니다.
- `getDeclaredFields()`: 클래스에 선언된 모든 필드를 반환합니다 (상속받은 필드 제외).
- `getName()`: 필드의 이름을 반환합니다.
- `getType()`: 필드의 타입을 반환합니다.
- `setAccessible(true)`: private 필드에 접근할 수 있게 합니다.
- `get()`, `set()`: 필드의 값을 읽거나 설정합니다.
- `Method`: 클래스의 메서드를 나타내는 클래스입니다.
- `getDeclaredMethods()`: 클래스에 선언된 모든 메서드를 반환합니다.
- `getReturnType()`: 메서드의 반환 타입을 반환합니다.
- `getParameterTypes()`: 메서드의 매개변수 타입 배열을 반환합니다.
- `getMethod()`: 특정 이름과 매개변수 타입의 public 메서드를 찾습니다.
- `invoke()`: 메서드를 호출합니다. 첫 번째 인수는 호출할 객체, 나머지는 매개변수입니다.
- `Constructor<?>`: 생성자를 나타내는 클래스입니다.
- `newInstance()`: 생성자를 사용하여 객체를 생성합니다.

### 14.3 동적 프록시

```java
interface Calculator {
    int add(int a, int b);
    int multiply(int a, int b);
}

// 프록시 생성
Calculator proxy = (Calculator) Proxy.newProxyInstance(
        Calculator.class.getClassLoader(),
        new Class<?>[]{Calculator.class},
        (proxyObj, method, args) -> {
            System.out.println("메서드 호출: " + method.getName());

            // 실제 로직
            if ("add".equals(method.getName())) {
                return (Integer) args[0] + (Integer) args[1];
            } else if ("multiply".equals(method.getName())) {
                return (Integer) args[0] * (Integer) args[1];
            }
            return null;
        }
);

int result = proxy.add(5, 3);  // "메서드 호출: add" 출력 후 8 반환
```

**설명:**
- `동적 프록시`: 런타임에 인터페이스의 구현체를 생성하는 기능입니다.
- `Proxy.newProxyInstance()`: 동적 프록시 객체를 생성합니다.
- 첫 번째 매개변수: 클래스 로더
- 두 번째 매개변수: 구현할 인터페이스들의 배열
- 세 번째 매개변수: InvocationHandler (메서드 호출을 처리하는 람다 또는 객체)
- `InvocationHandler`: 프록시 메서드 호출을 가로채서 처리하는 인터페이스입니다.
- `method`: 호출된 메서드 정보
- `args`: 메서드에 전달된 인수들
- 프록시는 AOP(Aspect Oriented Programming)나 데코레이터 패턴 구현에 유용합니다.

---

## 15. 동시성 유틸리티 고급

### 15.1 CompletableFuture 완전 가이드

```java
// 비동기 작업 생성
CompletableFuture<String> future1 = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(1000); } catch (InterruptedException e) {}
    return "결과 1";
});

CompletableFuture<String> future2 = CompletableFuture.supplyAsync(() -> {
    try { Thread.sleep(1500); } catch (InterruptedException e) {}
    return "결과 2";
});

// 조합과 변환
CompletableFuture<String> combined = future1
        .thenCompose(result1 ->
                CompletableFuture.supplyAsync(() -> result1 + " + 추가처리"))
        .thenCombine(future2, (result1, result2) -> result1 + " & " + result2);

// 예외 처리
CompletableFuture<String> handled = CompletableFuture.supplyAsync(() -> {
    if (Math.random() > 0.5) {
        throw new RuntimeException("오류 발생");
    }
    return "성공";
}).exceptionally(throwable -> {
    System.out.println("예외 처리: " + throwable.getMessage());
    return "기본값";
}).handle((result, throwable) -> {
    if (throwable != null) {
        return "오류로 인한 기본값";
    }
    return result.toUpperCase();
});

// 여러 작업 조합
CompletableFuture<Object> anyOf = CompletableFuture.anyOf(future1, future2);
CompletableFuture<Void> allOf = CompletableFuture.allOf(future1, future2);
```

**설명:**
- `CompletableFuture`: Java 8에서 도입된 비동기 프로그래밍을 위한 클래스입니다.
- `supplyAsync()`: 값을 반환하는 비동기 작업을 생성합니다.
- `thenCompose()`: 이전 결과를 사용하여 새로운 CompletableFuture를 생성합니다 (flatMap과 유사).
- `thenCombine()`: 두 개의 독립적인 CompletableFuture의 결과를 결합합니다.
- `exceptionally()`: 예외가 발생했을 때 기본값을 제공합니다.
- `handle()`: 성공과 실패 모든 경우를 처리합니다.
- `anyOf()`: 여러 CompletableFuture 중 가장 먼저 완료되는 것의 결과를 반환합니다.
- `allOf()`: 모든 CompletableFuture가 완료될 때까지 기다립니다.
- 메서드 체이닝을 통해 복잡한 비동기 작업 흐름을 구성할 수 있습니다.

### 15.2 CountDownLatch와 CyclicBarrier

```java
// CountDownLatch - 일회성 동기화
CountDownLatch latch = new CountDownLatch(3);

for (int i = 0; i < 3; i++) {
        new Thread(() -> {
        // 작업 수행
        System.out.println("작업 완료");
        latch.countDown();  // 카운터 감소
    }).start();
}

        latch.await();  // 모든 작업 완료까지 대기
System.out.println("모든 작업 완료");

// CyclicBarrier - 재사용 가능한 동기화
CyclicBarrier barrier = new CyclicBarrier(3, () -> {
    System.out.println("모든 스레드가 도착했습니다!");
});

for (int i = 0; i < 3; i++) {
        new Thread(() -> {
        try {
        // 작업 수행
        barrier.await();  // 다른 스레드들 대기
// 모든 스레드가 도착한 후 계속 진행
        } catch (Exception e) {
        e.printStackTrace();
        }
                }).start();
}
```

**설명:**
- `CountDownLatch`: 지정된 수의 이벤트가 발생할 때까지 스레드를 대기시키는 동기화 도구입니다.
- 생성자에 카운트를 지정하고, `countDown()`으로 카운트를 감소시킵니다.
- `await()`: 카운트가 0이 될 때까지 현재 스레드를 대기시킵니다.
- 일회용이므로 카운트가 0이 되면 재사용할 수 없습니다.
- `CyclicBarrier`: 지정된 수의 스레드가 모두 barrier 지점에 도달할 때까지 기다리는 동기화 도구입니다.
- 생성자에 대기할 스레드 수와 선택적으로 모든 스레드가 도착했을 때 실행할 작업을 지정합니다.
- `await()`: barrier 지점에서 다른 스레드들을 기다립니다.
- 재사용 가능하므로 반복적인 동기화 작업에 사용할 수 있습니다.

### 15.3 Semaphore와 BlockingQueue

```java
// Semaphore - 리소스 접근 제한
Semaphore semaphore = new Semaphore(2);  // 최대 2개 스레드만 동시 접근

public void limitedResource() {
    try {
        semaphore.acquire();  // 허가 획득
        // 제한된 리소스 사용
        Thread.sleep(1000);
    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
    } finally {
        semaphore.release();  // 허가 반납
    }
}

// BlockingQueue - 생산자-소비자 패턴
BlockingQueue<String> queue = new ArrayBlockingQueue<>(10);

// 생산자
CompletableFuture.runAsync(() -> {
        for (int i = 0; i < 100; i++) {
        try {
        queue.put("Item " + i);  // 큐가 가득 차면 대기
        } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
            break;
                    }
                    }
                    });

// 소비자
                    CompletableFuture.runAsync(() -> {
        while (true) {
        try {
String item = queue.take();  // 큐가 비어있으면 대기
            System.out.println("처리: " + item);
        } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
            break;
                    }
                    }
                    });
```

**설명:**
- `Semaphore`: 지정된 수의 허가(permit)를 관리하는 동기화 도구입니다.
- 생성자에 허가 수를 지정합니다.
- `acquire()`: 허가를 획득합니다. 허가가 없으면 대기합니다.
- `release()`: 허가를 반납합니다. 일반적으로 finally 블록에서 호출합니다.
- 제한된 리소스(DB 연결, 파일 핸들 등)에 대한 동시 접근을 제어할 때 유용합니다.
- `BlockingQueue`: 큐가 가득 차거나 비어있을 때 블로킹되는 큐입니다.
- `ArrayBlockingQueue`: 고정 크기의 배열 기반 블로킹 큐입니다.
- `put()`: 큐에 요소를 추가합니다. 큐가 가득 차면 공간이 생길 때까지 대기합니다.
- `take()`: 큐에서 요소를 제거하고 반환합니다. 큐가 비어있으면 요소가 추가될 때까지 대기합니다.
- 생산자-소비자 패턴에서 스레드 간 안전한 데이터 전달에 사용됩니다.

---

## 16. 메모리 관리와 성능 최적화

### 16.1 WeakReference와 SoftReference

```java
import java.lang.ref.*;

// Strong Reference (일반 참조)
String strongRef = new String("Strong");

// Weak Reference - GC 대상이 되면 즉시 정리
WeakReference<String> weakRef = new WeakReference<>(new String("Weak"));
String retrieved = weakRef.get();  // null일 수 있음

// Soft Reference - 메모리 부족할 때만 정리
SoftReference<byte[]> softRef = new SoftReference<>(new byte[1024 * 1024]);
byte[] data = softRef.get();  // 메모리 여유 있으면 유지

// 캐시 구현 예시
public class SimpleCache<K, V> {
    private final Map<K, SoftReference<V>> cache = new ConcurrentHashMap<>();

    public V get(K key) {
        SoftReference<V> ref = cache.get(key);
        if (ref != null) {
            V value = ref.get();
            if (value != null) {
                return value;
            } else {
                cache.remove(key);  // GC된 항목 제거
            }
        }
        return null;
    }

    public void put(K key, V value) {
        cache.put(key, new SoftReference<>(value));
    }
}
```

**설명:**
- `Strong Reference`: 일반적인 참조로, GC 대상이 되지 않습니다.
- `WeakReference`: 약한 참조로, GC가 실행되면 즉시 정리됩니다.
- `get()`: WeakReference가 참조하는 객체를 반환합니다. 이미 GC되었으면 null을 반환합니다.
- `SoftReference`: 소프트 참조로, 메모리가 부족할 때만 정리됩니다.
- 캐시 구현에 유용하며, 메모리 부족 시 자동으로 캐시를 비워줍니다.
- `ConcurrentHashMap`: 멀티스레드 환경에서 안전한 HashMap입니다.
- 참조의 종류: Strong > Soft > Weak > Phantom 순으로 GC 우선순위가 높습니다.

### 16.2 메모리 모니터링

```java
import java.lang.management.*;

public class MemoryMonitor {
    public static void printMemoryInfo() {
        MemoryMXBean memoryBean = ManagementFactory.getMemoryMXBean();
        RuntimeMXBean runtimeBean = ManagementFactory.getRuntimeMXBean();

        // Heap 메모리 정보
        MemoryUsage heapUsage = memoryBean.getHeapMemoryUsage();
        System.out.println("=== Heap Memory ===");
        System.out.println("Init: " + formatBytes(heapUsage.getInit()));
        System.out.println("Used: " + formatBytes(heapUsage.getUsed()));
        System.out.println("Committed: " + formatBytes(heapUsage.getCommitted()));
        System.out.println("Max: " + formatBytes(heapUsage.getMax()));

        // Non-Heap 메모리 정보 (Method Area, Code Cache 등)
        MemoryUsage nonHeapUsage = memoryBean.getNonHeapMemoryUsage();
        System.out.println("=== Non-Heap Memory ===");
        System.out.println("Used: " + formatBytes(nonHeapUsage.getUsed()));

        // GC 정보
        List<GarbageCollectorMXBean> gcBeans = ManagementFactory.getGarbageCollectorMXBeans();
        for (GarbageCollectorMXBean gcBean : gcBeans) {
            System.out.println("GC Name: " + gcBean.getName());
            System.out.println("Collection Count: " + gcBean.getCollectionCount());
            System.out.println("Collection Time: " + gcBean.getCollectionTime() + "ms");
        }
    }

    private static String formatBytes(long bytes) {
        return String.format("%.2f MB", bytes / 1024.0 / 1024.0);
    }
}
```

**설명:**
- `MemoryMXBean`: JVM 메모리 사용량을 모니터링하는 관리 인터페이스입니다.
- `getHeapMemoryUsage()`: 힙 메모리 사용 정보를 반환합니다.
- `Init`: 초기 메모리 크기
- `Used`: 현재 사용 중인 메모리
- `Committed`: JVM이 사용할 수 있도록 보장된 메모리
- `Max`: 최대 사용 가능한 메모리
- `getNonHeapMemoryUsage()`: 힙이 아닌 메모리 영역 (메서드 영역, 코드 캐시 등)의 사용 정보를 반환합니다.
- `GarbageCollectorMXBean`: 가비지 컬렉터의 통계 정보를 제공합니다.
- `getCollectionCount()`: GC 실행 횟수를 반환합니다.
- `getCollectionTime()`: GC에 소요된 총 시간을 반환합니다.

---

## 17. 함수형 인터페이스 완전 가이드

### 17.1 기본 함수형 인터페이스들

```java
import java.util.function.*;

// Predicate<T> - 조건 검사
Predicate<String> isEmpty = String::isEmpty;
Predicate<String> isLong = s -> s.length() > 10;
Predicate<String> combined = isEmpty.or(isLong);

// Function<T, R> - 변환
Function<String, Integer> stringToLength = String::length;
Function<Integer, String> intToString = Object::toString;
Function<String, String> composite = stringToLength.andThen(intToString);

// Consumer<T> - 소비 (반환값 없음)
Consumer<String> printer = System.out::println;
Consumer<String> logger = s -> System.err.println("LOG: " + s);
Consumer<String> both = printer.andThen(logger);

// Supplier<T> - 공급 (매개변수 없음)
Supplier<String> randomString = () -> "Random-" + Math.random();
Supplier<List<String>> listSupplier = ArrayList::new;

// BiFunction<T, U, R> - 두 매개변수
BiFunction<String, String, String> concatenator = (a, b) -> a + b;
BiFunction<Integer, Integer, Integer> adder = Integer::sum;

// UnaryOperator<T> - 같은 타입 변환
UnaryOperator<String> toUpper = String::toUpperCase;
UnaryOperator<Integer> square = x -> x * x;

// BinaryOperator<T> - 같은 타입 두 매개변수
BinaryOperator<String> stringJoiner = (a, b) -> a + ", " + b;
BinaryOperator<Integer> max = Integer::max;
```

**설명:**
- `Predicate<T>`: 매개변수를 받아 boolean을 반환하는 함수형 인터페이스입니다.
- `or()`: 두 Predicate를 OR 조건으로 결합합니다.
- `Function<T, R>`: 매개변수 T를 받아 결과 R을 반환하는 함수형 인터페이스입니다.
- `andThen()`: 두 Function을 연결하여 합성 함수를 만듭니다.
- `Consumer<T>`: 매개변수를 받아 소비하고 반환값이 없는 함수형 인터페이스입니다.
- `Supplier<T>`: 매개변수 없이 값을 공급하는 함수형 인터페이스입니다.
- `BiFunction<T, U, R>`: 두 개의 매개변수를 받아 결과를 반환합니다.
- `UnaryOperator<T>`: Function<T, T>의 특수형으로, 같은 타입을 받아 같은 타입을 반환합니다.
- `BinaryOperator<T>`: BiFunction<T, T, T>의 특수형으로, 같은 타입 두 개를 받아 같은 타입을 반환합니다.

### 17.2 특수 함수형 인터페이스들

```java
// 기본 타입 특화 인터페이스들 (박싱/언박싱 오버헤드 제거)
IntPredicate isEven = x -> x % 2 == 0;
IntFunction<String> intToString = Integer::toString;
ToIntFunction<String> stringToInt = Integer::parseInt;

IntSupplier randomInt = () -> (int)(Math.random() * 100);
IntConsumer printer = System.out::println;

IntUnaryOperator doubler = x -> x * 2;
IntBinaryOperator adder = Integer::sum;

// 스트림에서 활용
IntStream.range(1, 10)
    .filter(isEven)
    .map(doubler)
    .forEach(printer);

// 커스텀 함수형 인터페이스
@FunctionalInterface
interface TriFunction<T, U, V, R> {
    R apply(T t, U u, V v);

    // 기본 메서드 추가 가능
    default <W> TriFunction<T, U, V, W> andThen(Function<? super R, ? extends W> after) {
        return (t, u, v) -> after.apply(apply(t, u, v));
    }
}

TriFunction<Integer, Integer, Integer, Integer> sum3 = (a, b, c) -> a + b + c;
Integer result = sum3.apply(1, 2, 3);  // 6
```

**설명:**
- `IntPredicate`, `IntFunction` 등: 기본 타입(int, long, double)에 특화된 함수형 인터페이스입니다.
- 박싱/언박싱 오버헤드를 제거하여 성능을 향상시킵니다.
- `ToIntFunction<T>`: 매개변수를 받아 int를 반환합니다.
- `IntSupplier`: 매개변수 없이 int를 반환합니다.
- `IntUnaryOperator`: int를 받아 int를 반환합니다.
- `IntBinaryOperator`: 두 int를 받아 int를 반환합니다.
- `@FunctionalInterface`: 함수형 인터페이스임을 명시하는 어노테이션입니다.
- 사용자 정의 함수형 인터페이스를 만들 때 추상 메서드는 하나만 있어야 합니다.
- `default` 메서드는 함수형 인터페이스에 추가할 수 있습니다.

---

이렇게 Java 내장 함수들의 각 코드 블럭에 대해 상세한 설명을 추가했습니다. 각 함수의 목적, 사용법, 주의사항 등을 명확하게 설명했습니다. 더 궁금한 부분이 있으시면 언제든 물어보세요!