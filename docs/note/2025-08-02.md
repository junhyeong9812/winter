# Java 파일 업로드 시스템 완전 분석

## 1. MultipartParser.java 완전 분석

### 클래스 개요
```java
/**
 * HTTP Multipart 요청을 파싱하는 유틸리티 클래스
 * 
 * RFC 2388 Multipart 표준에 따라 multipart/form-data를 처리합니다.
 * boundary를 기준으로 각 part를 분리하고, 파일과 일반 파라미터를 구분합니다.
 */
public class MultipartParser {
```

### 상수 정의
```java
// 클래스 내부에서 사용되는 상수들
private static final String BOUNDARY_PREFIX = "--";           // boundary 접두사
private static final String CONTENT_DISPOSITION = "Content-Disposition"; // 헤더명
private static final String CONTENT_TYPE = "Content-Type";    // 헤더명
private static final String FORM_DATA = "form-data";          // disposition 타입
private static final String FILENAME = "filename";            // 파일명 속성
private static final String NAME = "name";                    // 이름 속성
private static final String CRLF = "\r\n";                   // 줄바꿈 문자
```

### 1.1 parseRequest() 메서드 (메인 진입점)
```java
/**
 * HttpRequest를 MultipartRequest로 파싱합니다.
 * 
 * multipart/form-data 요청을 파싱하여 파일과 일반 파라미터를 분리합니다.
 * 
 * @param request 원본 HTTP 요청
 * @return 파싱된 Multipart 요청
 * @throws IOException 파싱 실패시
 * @throws IllegalArgumentException multipart 요청이 아니거나 boundary가 없을 때
 */
public static MultipartRequest parseRequest(HttpRequest request) throws IOException {
    // 1단계: Content-Type 헤더 검증
    String contentType = request.getHeader("Content-Type");
    // null 체크 및 multipart/form-data 여부 확인
    if (contentType == null || !contentType.toLowerCase().startsWith("multipart/form-data")) {
        throw new IllegalArgumentException("Request is not multipart/form-data");
    }
    
    // 2단계: boundary 문자열 추출
    String boundary = extractBoundary(contentType);
    if (boundary == null) {
        throw new IllegalArgumentException("No boundary found in Content-Type");
    }
    
    // 3단계: HTTP 요청 본문을 문자열로 읽기
    String body = readRequestBody(request);
    
    // 4단계: 결과를 저장할 컬렉션 준비
    // 기존 파라미터를 복사하여 새로운 HashMap 생성
    Map<String, List<String>> parameters = new HashMap<>(request.getParameters());
    // 파일을 저장할 새로운 HashMap 생성
    Map<String, List<MultipartFile>> files = new HashMap<>();
    
    // 5단계: boundary를 기준으로 파트들을 분리하고 파싱
    parseParts(body, boundary, parameters, files);
    
    // 6단계: 결과를 담은 MultipartRequest 객체 생성 및 반환
    return new MultipartRequest(
        request.getMethod(),    // HTTP 메서드 (GET, POST 등)
        request.getPath(),      // 요청 경로
        request.getHeaders(),   // HTTP 헤더들
        parameters,             // 일반 파라미터들
        request.getBody(),      // 원본 요청 본문
        files                   // 파싱된 파일들
    );
}
```

**사용된 Java 메서드들:**
- `getHeader(String)`: HTTP 헤더 값을 가져오는 메서드
- `toLowerCase()`: 문자열을 소문자로 변환 (대소문자 무관 비교를 위해)
- `startsWith(String)`: 문자열이 특정 접두사로 시작하는지 확인
- `HashMap(Map)`: 기존 맵을 복사하여 새로운 HashMap 생성하는 복사 생성자

### 1.2 extractBoundary() 메서드
```java
/**
 * Content-Type 헤더에서 boundary를 추출합니다.
 * 
 * 예: "multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW"
 * 
 * @param contentType Content-Type 헤더값
 * @return boundary 문자열, 없으면 null
 */
private static String extractBoundary(String contentType) {
    // Content-Type을 세미콜론으로 분리
    // "multipart/form-data; boundary=value; charset=utf-8" 형태를 처리
    String[] parts = contentType.split(";");
    
    // 분리된 각 부분을 순회하며 boundary 찾기
    for (String part : parts) {
        part = part.trim(); // 앞뒤 공백 제거
        
        // "boundary="로 시작하는 부분 찾기
        if (part.startsWith("boundary=")) {
            // "boundary=" 이후의 값 추출 (9는 "boundary="의 길이)
            String boundary = part.substring("boundary=".length()).trim();
            
            // HTTP 헤더에서 값이 따옴표로 감싸져 있을 수 있으므로 제거
            if (boundary.startsWith("\"") && boundary.endsWith("\"")) {
                // 첫 번째와 마지막 따옴표 제거
                boundary = boundary.substring(1, boundary.length() - 1);
            }
            return boundary;
        }
    }
    return null; // boundary를 찾지 못한 경우
}
```

**사용된 Java 메서드들:**
- `split(String)`: 문자열을 지정된 구분자로 분리하여 String 배열 반환
- `trim()`: 문자열 앞뒤의 공백 문자(스페이스, 탭, 개행 등) 제거
- `substring(int)`: 지정된 인덱스부터 문자열 끝까지 추출
- `substring(int, int)`: 시작 인덱스부터 끝 인덱스 전까지 추출
- `length()`: 문자열의 길이 반환
- `endsWith(String)`: 문자열이 특정 접미사로 끝나는지 확인

### 1.3 readRequestBody() 메서드
```java
/**
 * 요청 본문을 문자열로 읽습니다.
 * 
 * @param request HTTP 요청
 * @return 요청 본문 문자열
 * @throws IOException 읽기 실패시
 */
private static String readRequestBody(HttpRequest request) throws IOException {
    // 문자열을 효율적으로 조작하기 위한 StringBuilder 생성
    StringBuilder sb = new StringBuilder();
    // HTTP 요청 본문을 읽기 위한 BufferedReader 획득
    BufferedReader reader = request.getBody();
    String line; // 한 줄씩 읽어올 임시 변수
    
    // 첫 번째 줄인지 확인하는 플래그 (CRLF 처리를 위해)
    boolean first = true;
    
    // 파일 끝까지 한 줄씩 읽기
    while ((line = reader.readLine()) != null) {
        if (!first) {
            // 첫 번째 줄이 아니면 줄바꿈 문자 추가
            // multipart에서는 CRLF가 중요한 구분자 역할
            sb.append(CRLF);
        }
        sb.append(line); // 현재 줄 내용 추가
        first = false;   // 첫 번째 줄 플래그 해제
    }
    
    // StringBuilder의 내용을 String으로 변환하여 반환
    return sb.toString();
}
```

**사용된 Java 메서드들:**
- `StringBuilder()`: 가변 길이 문자열을 효율적으로 조작하기 위한 클래스의 기본 생성자
- `readLine()`: BufferedReader에서 한 줄을 읽어오는 메서드 (줄바꿈 문자는 제외)
- `append(String)`: StringBuilder에 문자열을 끝에 추가하는 메서드
- `toString()`: StringBuilder의 내용을 String 객체로 변환

### 1.4 parseParts() 메서드
```java
/**
 * boundary를 기준으로 파트를 분리하고 파싱합니다.
 * 
 * @param body 요청 본문
 * @param boundary boundary 문자열
 * @param parameters 일반 파라미터 맵 (출력)
 * @param files 파일 맵 (출력)
 */
private static void parseParts(String body, String boundary, 
                             Map<String, List<String>> parameters,
                             Map<String, List<MultipartFile>> files) {
    
    // boundary 구분자 생성
    // RFC 2388에 따라 boundary 앞에 "--"를 붙임
    String delimiter = BOUNDARY_PREFIX + boundary; // 예: "--WebKitFormBoundary123"
    // 끝을 나타내는 구분자 (추가로 "--"가 더 붙음)
    String endDelimiter = delimiter + BOUNDARY_PREFIX; // 예: "--WebKitFormBoundary123--"
    
    // 시작 boundary의 위치 찾기
    int startIndex = body.indexOf(delimiter);
    // 끝 boundary의 위치 찾기 (마지막에 나타나는 것)
    int endIndex = body.lastIndexOf(endDelimiter);
    
    if (startIndex == -1) {
        return; // boundary를 찾을 수 없으면 파싱 중단
    }
    
    // 실제 데이터 부분만 추출 (시작 boundary 이후부터 끝 boundary 이전까지)
    String content = body.substring(startIndex + delimiter.length(), 
                                  endIndex != -1 ? endIndex : body.length());
    
    // delimiter로 각 파트 분리
    // 각 파트는 boundary로 구분되어 있음
    String[] parts = content.split(delimiter);
    
    // 분리된 각 파트를 순회하며 개별 파싱
    for (String part : parts) {
        part = part.trim(); // 앞뒤 공백 제거
        if (!part.isEmpty()) { // 빈 파트가 아닌 경우에만 파싱
            parsePart(part, parameters, files);
        }
    }
}
```

**사용된 Java 메서드들:**
- `indexOf(String)`: 문자열에서 특정 부분 문자열이 처음 나타나는 위치 반환 (0부터 시작, 없으면 -1)
- `lastIndexOf(String)`: 문자열에서 특정 부분 문자열이 마지막으로 나타나는 위치 반환
- `split(String)`: 정규표현식이 아닌 리터럴 문자열로 분리 (여기서는 boundary 문자열로 분리)
- `isEmpty()`: 문자열의 길이가 0인지 확인하는 메서드

### 1.5 parsePart() 메서드
```java
/**
 * 개별 파트를 파싱합니다.
 * 
 * @param part 파트 내용
 * @param parameters 일반 파라미터 맵 (출력)
 * @param files 파일 맵 (출력)
 */
private static void parsePart(String part, 
                            Map<String, List<String>> parameters,
                            Map<String, List<MultipartFile>> files) {
    
    // multipart에서 헤더와 바디는 빈 줄(CRLF+CRLF)로 구분됨
    int headerEndIndex = part.indexOf(CRLF + CRLF);
    if (headerEndIndex == -1) {
        return; // 올바르지 않은 파트 형식이면 건너뛰기
    }
    
    // 헤더 섹션 추출 (처음부터 빈 줄 이전까지)
    String headerSection = part.substring(0, headerEndIndex);
    // 바디 섹션 추출 (빈 줄 이후부터 끝까지)
    String bodySection = part.substring(headerEndIndex + (CRLF + CRLF).length());
    
    // 헤더 섹션을 파싱하여 헤더명-값 맵으로 변환
    Map<String, String> headers = parseHeaders(headerSection);
    
    // Content-Disposition 헤더 확인 (필수 헤더)
    String contentDisposition = headers.get(CONTENT_DISPOSITION.toLowerCase());
    if (contentDisposition == null || !contentDisposition.toLowerCase().contains(FORM_DATA)) {
        return; // form-data가 아니면 무시
    }
    
    // Content-Disposition에서 name과 filename 속성 추출
    String name = extractAttribute(contentDisposition, NAME);
    String filename = extractAttribute(contentDisposition, FILENAME);
    
    if (name == null) {
        return; // name 속성이 없으면 무시 (필수 속성)
    }
    
    // filename 속성 유무로 파일과 일반 파라미터 구분
    if (filename != null) {
        // 파일 파라미터 처리
        
        // Content-Type 헤더 추출 (옵션)
        String contentType = headers.get(CONTENT_TYPE.toLowerCase());
        // 바디 섹션을 바이트 배열로 변환 (파일 내용)
        byte[] fileContent = bodySection.getBytes(StandardCharsets.UTF_8);
        
        // MultipartFile 객체 생성
        MultipartFile multipartFile = new StandardMultipartFile(
            name,           // 파라미터 이름
            filename,       // 파일명
            contentType,    // MIME 타입
            fileContent     // 파일 내용
        );
        
        // 파일 맵에 추가 (같은 name에 여러 파일이 올 수 있으므로 List 사용)
        files.computeIfAbsent(name, k -> new ArrayList<>()).add(multipartFile);
    } else {
        // 일반 파라미터 처리
        
        // 파라미터 맵에 추가 (같은 name에 여러 값이 올 수 있으므로 List 사용)
        parameters.computeIfAbsent(name, k -> new ArrayList<>()).add(bodySection);
    }
}
```

**사용된 Java 메서드들:**
- `contains(String)`: 문자열이 특정 부분 문자열을 포함하는지 확인
- `getBytes(Charset)`: 문자열을 지정된 문자 인코딩으로 바이트 배열 변환
- `computeIfAbsent(K, Function)`: 맵에서 키가 없으면 함수를 실행하여 새 값을 생성하고 추가하는 메서드
- `ArrayList<>()`: 동적 크기 조절이 가능한 배열 리스트의 기본 생성자
- `add(E)`: 리스트의 끝에 요소를 추가하는 메서드

### 1.6 parseHeaders() 메서드
```java
/**
 * 헤더 섹션을 파싱하여 맵으로 변환합니다.
 * 
 * @param headerSection 헤더 섹션 문자열
 * @return 헤더명(소문자) -> 헤더값 맵
 */
private static Map<String, String> parseHeaders(String headerSection) {
    // 헤더를 저장할 맵 생성
    Map<String, String> headers = new HashMap<>();
    // 헤더 섹션을 줄바꿈으로 분리
    String[] lines = headerSection.split(CRLF);
    
    // 각 줄을 순회하며 헤더 파싱
    for (String line : lines) {
        line = line.trim(); // 앞뒤 공백 제거
        if (line.isEmpty()) {
            continue; // 빈 줄은 건너뛰기
        }
        
        // 콜론(:)을 기준으로 헤더명과 값 분리
        int colonIndex = line.indexOf(':');
        if (colonIndex > 0) { // 콜론이 있고 첫 번째 문자가 아닌 경우
            // 헤더명 추출 (콜론 이전) 및 소문자 변환
            String headerName = line.substring(0, colonIndex).trim().toLowerCase();
            // 헤더값 추출 (콜론 이후)
            String headerValue = line.substring(colonIndex + 1).trim();
            // 맵에 저장
            headers.put(headerName, headerValue);
        }
    }
    
    return headers;
}
```

**사용된 Java 메서드들:**
- `HashMap<>()`: 해시테이블 기반의 맵 구현체 기본 생성자
- `continue`: 반복문에서 현재 반복을 건너뛰고 다음 반복으로 이동하는 키워드
- `indexOf(char)`: 문자열에서 특정 문자가 처음 나타나는 위치 반환
- `put(K, V)`: 맵에 키-값 쌍을 추가하는 메서드

### 1.7 extractAttribute() 메서드 (핵심 함수)
```java
/**
 * Content-Disposition에서 특정 속성값을 추출합니다.
 * 
 * 예: 'form-data; name="file"; filename="test.txt"'에서
 * extractAttribute(contentDisposition, "name") → "file"
 * 
 * @param contentDisposition Content-Disposition 헤더값
 * @param attributeName 추출할 속성명
 * @return 속성값, 없으면 null
 */
private static String extractAttribute(String contentDisposition, String attributeName) {
    // 속성값 추출을 위한 두 가지 패턴 정의
    // 패턴1: name="value" (따옴표로 감싸진 값)
    String pattern1 = attributeName + "=\"";
    // 패턴2: name=value (따옴표 없는 값)
    String pattern2 = attributeName + "=";
    
    // 먼저 따옴표가 있는 패턴 확인
    int startIndex = contentDisposition.indexOf(pattern1);
    if (startIndex != -1) {
        // 따옴표 있는 패턴 발견
        // "name=\"" 다음 위치부터 시작
        startIndex += pattern1.length();
        // 닫는 따옴표 위치 찾기
        int endIndex = contentDisposition.indexOf('"', startIndex);
        if (endIndex != -1) {
            // 따옴표 사이의 값 반환
            return contentDisposition.substring(startIndex, endIndex);
        }
    } else {
        // 따옴표 없는 패턴 확인
        startIndex = contentDisposition.indexOf(pattern2);
        if (startIndex != -1) {
            // "name=" 다음 위치부터 시작
            startIndex += pattern2.length();
            // 세미콜론 또는 문자열 끝까지 찾기
            int endIndex = contentDisposition.indexOf(';', startIndex);
            if (endIndex == -1) {
                // 세미콜론이 없으면 문자열 끝까지
                endIndex = contentDisposition.length();
            }
            // 값 반환 (앞뒤 공백 제거)
            return contentDisposition.substring(startIndex, endIndex).trim();
        }
    }
    
    return null; // 속성을 찾지 못한 경우
}
```

**사용된 Java 메서드들:**
- `indexOf(String)`: 문자열에서 부분 문자열의 첫 번째 위치
- `indexOf(char, int)`: 지정된 위치부터 문자를 찾는 메서드

---

## 2. UploadConfig.java 완전 분석

### 클래스 개요 및 상수
```java
/**
 * 파일 업로드 관련 설정을 관리하는 클래스
 * 
 * 업로드 디렉토리, 파일 크기 제한, 허용 확장자 등
 * 파일 업로드와 관련된 모든 설정을 중앙에서 관리합니다.
 */
public class UploadConfig {
    
    // 기본 설정값들 - static final로 불변 상수 선언
    private static final String DEFAULT_UPLOAD_DIR = "./uploads";
    private static final long DEFAULT_MAX_FILE_SIZE = 10 * 1024 * 1024; // 10MB
    private static final long DEFAULT_MAX_REQUEST_SIZE = 50 * 1024 * 1024; // 50MB
    private static final String[] DEFAULT_ALLOWED_EXTENSIONS = {
        ".jpg", ".jpeg", ".png", ".gif", ".bmp",  // 이미지 파일들
        ".pdf", ".doc", ".docx", ".txt", ".rtf",  // 문서 파일들
        ".zip", ".rar", ".7z",                    // 압축 파일들
        ".mp3", ".wav", ".mp4", ".avi"            // 미디어 파일들
    };
    
    // 인스턴스 필드들
    private String uploadDir;              // 업로드 디렉토리 경로
    private long maxFileSize;              // 개별 파일 최대 크기
    private long maxRequestSize;           // 전체 요청 최대 크기
    private String[] allowedExtensions;    // 허용된 파일 확장자 목록
    private boolean createUploadDir;       // 업로드 디렉토리 자동 생성 여부
    private boolean overwriteExisting;     // 기존 파일 덮어쓰기 허용 여부
```

### 2.1 생성자들
```java
/**
 * 기본 설정으로 UploadConfig를 생성합니다.
 */
public UploadConfig() {
    // 모든 필드를 기본값으로 초기화
    this.uploadDir = DEFAULT_UPLOAD_DIR;                        // "./uploads"
    this.maxFileSize = DEFAULT_MAX_FILE_SIZE;                   // 10MB
    this.maxRequestSize = DEFAULT_MAX_REQUEST_SIZE;             // 50MB
    this.allowedExtensions = DEFAULT_ALLOWED_EXTENSIONS.clone(); // 기본 확장자 목록 복사
    this.createUploadDir = true;                                // 자동 생성 허용
    this.overwriteExisting = true;                              // 덮어쓰기 허용
}

/**
 * 지정된 업로드 디렉토리로 UploadConfig를 생성합니다.
 * 
 * @param uploadDir 업로드 디렉토리 경로
 */
public UploadConfig(String uploadDir) {
    this(); // 기본 생성자 호출 (다른 필드들은 기본값으로 설정)
    // 업로드 디렉토리만 사용자 지정값으로 변경 (null 안전성 확보)
    this.uploadDir = uploadDir != null ? uploadDir : DEFAULT_UPLOAD_DIR;
}
```

**사용된 Java 개념들:**
- `clone()`: 배열의 얕은 복사를 수행하는 메서드 (원본 배열과 독립적인 새 배열 생성)
- `this()`: 같은 클래스의 다른 생성자를 호출하는 키워드
- 삼항 연산자 `condition ? value1 : value2`: 조건부 값 할당

### 2.2 Getter 메서드들
```java
/**
 * 업로드 디렉토리 경로를 반환합니다.
 * 
 * @return 업로드 디렉토리 경로
 */
public String getUploadDir() {
    return uploadDir; // 단순히 필드값 반환
}

/**
 * 최대 파일 크기를 반환합니다. (바이트 단위)
 * 
 * @return 최대 파일 크기
 */
public long getMaxFileSize() {
    return maxFileSize; // 필드값 반환
}

/**
 * 최대 요청 크기를 반환합니다. (바이트 단위)
 * 
 * @return 최대 요청 크기
 */
public long getMaxRequestSize() {
    return maxRequestSize; // 필드값 반환
}

/**
 * 허용된 파일 확장자 목록을 반환합니다.
 * 
 * @return 허용된 확장자 배열 (복사본)
 */
public String[] getAllowedExtensions() {
    return allowedExtensions.clone(); // 방어적 복사 - 원본 배열 보호
}

/**
 * 업로드 디렉토리 자동 생성 여부를 반환합니다.
 * 
 * @return 자동 생성 여부
 */
public boolean isCreateUploadDir() {
    return createUploadDir; // boolean 필드값 반환
}

/**
 * 기존 파일 덮어쓰기 여부를 반환합니다.
 * 
 * @return 덮어쓰기 허용 여부
 */
public boolean isOverwriteExisting() {
    return overwriteExisting; // boolean 필드값 반환
}
```

**사용된 Java 개념들:**
- 방어적 복사(Defensive Copy): 내부 배열을 직접 노출하지 않고 복사본을 반환하여 캡슐화 보장

### 2.3 Setter 메서드들 (빌더 패턴)
```java
/**
 * 업로드 디렉토리 경로를 설정합니다.
 * 
 * @param uploadDir 업로드 디렉토리 경로
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig setUploadDir(String uploadDir) {
    // null 안전성을 위한 검증 후 설정
    this.uploadDir = uploadDir != null ? uploadDir : DEFAULT_UPLOAD_DIR;
    return this; // 메서드 체이닝을 위해 자신의 참조 반환
}

/**
 * 최대 파일 크기를 설정합니다. (바이트 단위)
 * 
 * @param maxFileSize 최대 파일 크기
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig setMaxFileSize(long maxFileSize) {
    // 음수 방지를 위해 0과 입력값 중 큰 값 선택
    this.maxFileSize = Math.max(0, maxFileSize);
    return this; // 체이닝 지원
}

/**
 * 최대 요청 크기를 설정합니다. (바이트 단위)
 * 
 * @param maxRequestSize 최대 요청 크기
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig setMaxRequestSize(long maxRequestSize) {
    // 음수 방지 처리
    this.maxRequestSize = Math.max(0, maxRequestSize);
    return this; // 체이닝 지원
}

/**
 * 허용된 파일 확장자 목록을 설정합니다.
 * 
 * @param allowedExtensions 허용된 확장자 배열
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig setAllowedExtensions(String... allowedExtensions) {
    // 가변인자로 받은 배열을 복사하여 저장 (null 안전성 포함)
    this.allowedExtensions = allowedExtensions != null ? 
        allowedExtensions.clone() : DEFAULT_ALLOWED_EXTENSIONS.clone();
    return this; // 체이닝 지원
}

/**
 * 업로드 디렉토리 자동 생성 여부를 설정합니다.
 * 
 * @param createUploadDir 자동 생성 여부
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig setCreateUploadDir(boolean createUploadDir) {
    this.createUploadDir = createUploadDir; // boolean 값 직접 할당
    return this; // 체이닝 지원
}

/**
 * 기존 파일 덮어쓰기 여부를 설정합니다.
 * 
 * @param overwriteExisting 덮어쓰기 허용 여부
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig setOverwriteExisting(boolean overwriteExisting) {
    this.overwriteExisting = overwriteExisting; // boolean 값 직접 할당
    return this; // 체이닝 지원
}
```

**사용된 Java 메서드들:**
- `Math.max(long, long)`: 두 long 값 중 더 큰 값을 반환하는 정적 메서드
- 가변인자 `String...`: 메서드가 0개 이상의 String 인자를 받을 수 있게 하는 문법

### 2.4 편의 메서드들
```java
/**
 * 편의 메서드: 이미지 파일만 허용하도록 설정합니다.
 * 
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig allowImagesOnly() {
    // 이미지 확장자로만 제한된 새 배열 생성 및 할당
    this.allowedExtensions = new String[]{".jpg", ".jpeg", ".png", ".gif", ".bmp"};
    return this; // 체이닝 지원
}

/**
 * 편의 메서드: 문서 파일만 허용하도록 설정합니다.
 * 
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig allowDocumentsOnly() {
    // 문서 확장자로만 제한된 새 배열 생성 및 할당
    this.allowedExtensions = new String[]{".pdf", ".doc", ".docx", ".txt", ".rtf"};
    return this; // 체이닝 지원
}

/**
 * 편의 메서드: 모든 파일을 허용하도록 설정합니다.
 * 
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig allowAllFiles() {
    // 빈 배열 할당 = 확장자 제한 없음을 의미
    this.allowedExtensions = new String[0];
    return this; // 체이닝 지원
}

/**
 * 편의 메서드: 파일 크기를 MB 단위로 설정합니다.
 * 
 * @param maxFileSizeMB 최대 파일 크기 (MB)
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig setMaxFileSizeMB(int maxFileSizeMB) {
    // MB를 바이트로 변환 (1MB = 1024KB = 1024 * 1024 bytes)
    this.maxFileSize = (long) maxFileSizeMB * 1024 * 1024;
    return this; // 체이닝 지원
}

/**
 * 편의 메서드: 요청 크기를 MB 단위로 설정합니다.
 * 
 * @param maxRequestSizeMB 최대 요청 크기 (MB)
 * @return 체이닝을 위한 this 객체
 */
public UploadConfig setMaxRequestSizeMB(int maxRequestSizeMB) {
    // MB를 바이트로 변환
    this.maxRequestSize = (long) maxRequestSizeMB * 1024 * 1024;
    return this; // 체이닝 지원
}
```

**사용된 Java 개념들:**
- 배열 리터럴 `new String[]{...}`: 새 배열을 생성하고 초기값으로 초기화
- 명시적 형변환 `(long)`: int를 long으로 변환하여 오버플로우 방지

### 2.5 toString() 메서드
```java
/**
 * 설정 정보를 문자열로 반환합니다.
 * 
 * @return 설정 정보 문자열
 */
@Override
public String toString() {
    // 객체의 모든 필드 정보를 포함한 문자열 생성
    return "UploadConfig{" +
            "uploadDir='" + uploadDir + '\'' +                    // 문자열 필드
            ", maxFileSize=" + maxFileSize + " bytes" +           // 숫자 + 단위
            ", maxRequestSize=" + maxRequestSize + " bytes" +     // 숫자 + 단위
            ", allowedExtensions=" + Arrays.toString(allowedExtensions) + // 배열 내용
            ", createUploadDir=" + createUploadDir +              // boolean 값
            ", overwriteExisting=" + overwriteExisting +          // boolean 값
            '}';
}
```

**사용된 Java 메서드들:**
- `@Override`: 부모 클래스(Object)의 메서드를 재정의함을 컴파일러에 알리는 어노테이션
- `Arrays.toString(Object[])`: 배열의 모든 요소를 문자열로 변환하는 정적 메서드

---

## 3. FileUploadUtil.java 완전 분석

### 클래스 개요 및 상수
```java
/**
 * 파일 업로드 관련 유틸리티 메서드를 제공하는 클래스
 * 
 * 파일명 생성, 확장자 검증, 디렉토리 관리, 보안 검증 등
 * 파일 업로드와 관련된 다양한 유틸리티 기능을 제공합니다.
 */
public class FileUploadUtil {
    
    // 위험한 파일명 패턴을 탐지하는 정규표현식
    private static final Pattern DANGEROUS_FILENAME_PATTERN = 
        Pattern.compile(".*[<>:\"|?*\\\\/.]+.*");
    
    // 보안상 위험한 실행 파일 확장자들
    private static final String[] DANGEROUS_EXTENSIONS = {
        ".exe", ".bat", ".cmd", ".com", ".scr", ".pif", ".vbs", ".js", ".jar", ".sh"
    };
    
    // 인스턴스 생성 방지를 위한 private 생성자
    private FileUploadUtil() {
        // 유틸리티 클래스는 인스턴스 생성을 허용하지 않음
    }
```

**사용된 Java 개념들:**
- `Pattern.compile(String)`: 정규표현식 문자열을 Pattern 객체로 컴파일하는 정적 메서드
- 정규표현식 `.*[<>:\"|?*\\\\/.]+.*`: 위험한 문자들을 포함한 문자열 매칭

### 3.1 파일명 생성 메서드들
```java
/**
 * 원본 파일명을 기반으로 고유한 파일명을 생성합니다.
 * 
 * UUID를 사용하여 고유성을 보장하고 원본 확장자를 유지합니다.
 * 
 * @param originalFilename 원본 파일명
 * @return 고유한 파일명 (UUID + 확장자)
 */
public static String generateUniqueFileName(String originalFilename) {
    // null이나 빈 문자열 처리
    if (originalFilename == null || originalFilename.trim().isEmpty()) {
        return UUID.randomUUID().toString(); // 확장자 없이 UUID만 반환
    }
    
    // 원본 파일에서 확장자 추출
    String extension = getFileExtension(originalFilename);
    // UUID + 확장자 조합으로 고유한 파일명 생성
    return UUID.randomUUID().toString() + extension;
}

/**
 * 타임스탬프를 포함한 고유한 파일명을 생성합니다.
 * 
 * @param originalFilename 원본 파일명
 * @return 타임스탬프가 포함된 고유한 파일명
 */
public static String generateTimestampFileName(String originalFilename) {
    // null이나 빈 문자열 처리
    if (originalFilename == null || originalFilename.trim().isEmpty()) {
        return generateTimestamp(); // 타임스탬프만 반환
    }
    
    // 원본 파일명에서 이름과 확장자 분리
    String nameWithoutExt = getFileNameWithoutExtension(originalFilename);
    String extension = getFileExtension(originalFilename);
    String timestamp = generateTimestamp();
    
    // "안전한파일명_타임스탬프.확장자" 형태로 조합
    return sanitizeFileName(nameWithoutExt) + "_" + timestamp + extension;
}
```

**사용된 Java 메서드들:**
- `UUID.randomUUID()`: 128비트 고유 식별자를 생성하는 정적 메서드
- `toString()`: UUID 객체를 하이픈으로 구분된 문자열로 변환

### 3.2 파일 확장자 처리 메서드들
```java
/**
 * 파일명에서 확장자를 추출합니다.
 * 
 * @param filename 파일명
 * @return 확장자 (점 포함), 확장자가 없으면 빈 문자열
 */
public static String getFileExtension(String filename) {
    // null이나 빈 문자열 검증
    if (filename == null || filename.trim().isEmpty()) {
        return ""; // 빈 문자열 반환
    }
    
    // 마지막 점(.)의 위치 찾기
    int lastDotIndex = filename.lastIndexOf('.');
    // 점이 없거나 파일명이 점으로 끝나는 경우 (확장자 없음)
    if (lastDotIndex == -1 || lastDotIndex == filename.length() - 1) {
        return ""; // 확장자 없음
    }
    
    // 점부터 끝까지 추출하고 소문자로 변환 (대소문자 통일)
    return filename.substring(lastDotIndex).toLowerCase();
}

/**
 * 파일명에서 확장자를 제외한 이름을 추출합니다.
 * 
 * @param filename 파일명
 * @return 확장자를 제외한 파일명
 */
public static String getFileNameWithoutExtension(String filename) {
    // null이나 빈 문자열 검증
    if (filename == null || filename.trim().isEmpty()) {
        return ""; // 빈 문자열 반환
    }
    
    // 마지막 점의 위치 찾기
    int lastDotIndex = filename.lastIndexOf('.');
    if (lastDotIndex == -1) {
        return filename; // 확장자가 없으면 전체 파일명 반환
    }
    
    // 처음부터 점 이전까지 반환
    return filename.substring(0, lastDotIndex);
}
```

**사용된 Java 메서드들:**
- `lastIndexOf(char)`: 문자열에서 특정 문자가 마지막으로 나타나는 위치 반환

### 3.3 파일 검증 메서드들
```java
/**
 * 파일의 확장자가 허용된 확장자 목록에 포함되는지 확인합니다.
 * 
 * @param filename 파일명
 * @param allowedExtensions 허용된 확장자 배열
 * @return 허용된 확장자면 true, 제한이 없으면(빈 배열) true
 */
public static boolean isAllowedExtension(String filename, String[] allowedExtensions) {
    // 허용 목록이 null이거나 비어있으면 모든 확장자 허용
    if (allowedExtensions == null || allowedExtensions.length == 0) {
        return true; // 제한 없음
    }
    
    // 파일의 확장자 추출
    String extension = getFileExtension(filename);
    if (extension.isEmpty()) {
        return false; // 확장자가 없으면 거부
    }
    
    // 허용된 확장자 목록과 비교
    for (String allowed : allowedExtensions) {
        if (allowed != null && allowed.toLowerCase().equals(extension)) {
            return true; // 매칭되는 확장자 발견
        }
    }
    
    return false; // 허용되지 않은 확장자
}

/**
 * 파일 확장자가 위험한 실행 파일인지 확인합니다.
 * 
 * @param filename 파일명
 * @return 위험한 확장자면 true
 */
public static boolean isDangerousExtension(String filename) {
    String extension = getFileExtension(filename);
    if (extension.isEmpty()) {
        return false; // 확장자가 없으면 안전
    }
    
    // 위험한 확장자 목록과 비교
    for (String dangerous : DANGEROUS_EXTENSIONS) {
        if (dangerous.equals(extension)) {
            return true; // 위험한 확장자 발견
        }
    }
    
    return false; // 안전한 확장자
}

/**
 * 파일 크기가 허용된 최대 크기 이내인지 확인합니다.
 * 
 * @param size 파일 크기 (바이트)
 * @param maxSize 최대 허용 크기 (바이트)
 * @return 허용된 크기면 true
 */
public static boolean isValidFileSize(long size, long maxSize) {
    // 크기가 0 이상이고 최대 크기 이하인지 확인
    return size >= 0 && size <= maxSize;
}
```

**사용된 Java 개념들:**
- Enhanced for loop: `for (Type variable : collection)` 형태의 개선된 반복문
- `equals(Object)`: 객체의 내용 비교 메서드

### 3.4 디렉토리 관리 메서드들
```java
/**
 * 지정된 디렉토리가 존재하지 않으면 생성합니다.
 * 
 * @param dirPath 디렉토리 경로
 * @throws IOException 디렉토리 생성 실패시
 */
public static void ensureDirectoryExists(String dirPath) throws IOException {
    // 경로가 null이나 빈 문자열인지 검증
    if (dirPath == null || dirPath.trim().isEmpty()) {
        throw new IllegalArgumentException("Directory path cannot be null or empty");
    }
    
    // 문자열 경로를 Path 객체로 변환
    Path path = Paths.get(dirPath);
    if (!Files.exists(path)) {
        // 디렉토리가 존재하지 않으면 생성 (부모 디렉토리도 함께 생성)
        Files.createDirectories(path);
    } else if (!Files.isDirectory(path)) {
        // 경로가 존재하지만 디렉토리가 아닌 경우 (파일인 경우)
        throw new IOException("Path exists but is not a directory: " + dirPath);
    }
    // else: 디렉토리가 이미 존재하면 아무것도 하지 않음
}
```

**사용된 Java 메서드들:**
- `Paths.get(String)`: 문자열 경로를 Path 객체로 변환하는 정적 메서드
- `Files.exists(Path)`: 파일이나 디렉토리의 존재 여부를 확인하는 정적 메서드
- `Files.createDirectories(Path)`: 디렉토리를 생성하는 정적 메서드 (부모 디렉토리도 함께 생성)
- `Files.isDirectory(Path)`: 경로가 디렉토리인지 확인하는 정적 메서드

### 3.5 파일 보안 및 정리 메서드들
```java
/**
 * 안전한 파일명을 생성합니다. (위험한 문자 제거)
 * 
 * @param filename 원본 파일명
 * @return 안전한 파일명
 */
public static String sanitizeFileName(String filename) {
    // null이나 빈 문자열 처리
    if (filename == null || filename.trim().isEmpty()) {
        return "file_" + System.currentTimeMillis(); // 기본값 생성
    }
    
    // 단계별 보안 처리
    
    // 1. 경로 구분자 제거 (디렉토리 이동 방지)
    String sanitized = filename.replaceAll("[/\\\\]", "_");
    
    // 2. 위험한 특수문자 제거 (OS별 위험 문자)
    sanitized = sanitized.replaceAll("[<>:\"|?*]", "_");
    
    // 3. 상대 경로 표현 제거 (디렉토리 이동 공격 방지)
    sanitized = sanitized.replaceAll("\\.\\.", "_");
    
    // 4. 제어 문자 제거 (ASCII 0-31, 127)
    sanitized = sanitized.replaceAll("[\\x00-\\x1f\\x7f]", "_");
    
    // 5. 앞뒤 공백 및 점 제거 (OS별 문제 방지)
    sanitized = sanitized.trim()
                        .replaceAll("^\\.*", "")    // 앞의 점들 제거
                        .replaceAll("\\.*$", "");   // 뒤의 점들 제거
    
    // 6. 빈 문자열이 되면 기본값 사용
    if (sanitized.isEmpty()) {
        sanitized = "file_" + System.currentTimeMillis();
    }
    
    return sanitized;
}

/**
 * 안전한 파일 경로를 생성합니다. (경로 조작 공격 방지)
 * 
 * @param uploadDir 업로드 디렉토리
 * @param filename 파일명
 * @return 안전한 파일 경로
 */
public static String createSafeFilePath(String uploadDir, String filename) {
    // 파일명을 먼저 안전하게 처리
    String safeFilename = sanitizeFileName(filename);
    // OS에 안전한 방식으로 경로 결합
    return Paths.get(uploadDir, safeFilename).toString();
}
```

**사용된 Java 메서드들:**
- `replaceAll(String, String)`: 정규표현식 패턴과 일치하는 모든 부분을 교체하는 메서드
- `System.currentTimeMillis()`: 1970년 1월 1일부터 현재까지의 밀리초를 반환하는 정적 메서드
- 정규표현식:
    - `[/\\\\]`: 슬래시 또는 백슬래시
    - `[<>:\"|?*]`: 특수문자들
    - `\\.\\.`: 연속된 두 개의 점
    - `[\\x00-\\x1f\\x7f]`: 제어문자 범위
    - `^\\.*`: 문자열 시작의 점들
    - `\\.*$`: 문자열 끝의 점들

### 3.6 파일 크기 및 타입 유틸리티들
```java
/**
 * 파일 크기를 사람이 읽기 쉬운 형태로 변환합니다.
 * 
 * @param bytes 바이트 크기
 * @return 사람이 읽기 쉬운 형태의 크기 (예: "1.5 MB")
 */
public static String formatFileSize(long bytes) {
    // 음수 처리
    if (bytes < 0) {
        return "Unknown";
    // 1024 바이트 미만 (바이트 단위)
    } else if (bytes < 1024) {
        return bytes + " B";
    // 1MB 미만 (KB 단위)
    } else if (bytes < 1024 * 1024) {
        return String.format("%.1f KB", bytes / 1024.0);
    // 1GB 미만 (MB 단위)
    } else if (bytes < 1024 * 1024 * 1024) {
        return String.format("%.1f MB", bytes / (1024.0 * 1024));
    // 1GB 이상 (GB 단위)
    } else {
        return String.format("%.1f GB", bytes / (1024.0 * 1024 * 1024));
    }
}

/**
 * 파일이 이미지 파일인지 확인합니다.
 * 
 * @param contentType Content-Type 헤더값
 * @return 이미지 파일이면 true
 */
public static boolean isImageFile(String contentType) {
    // null 체크 후 MIME 타입 확인
    return contentType != null && contentType.toLowerCase().startsWith("image/");
}

/**
 * 파일이 텍스트 파일인지 확인합니다.
 * 
 * @param contentType Content-Type 헤더값
 * @return 텍스트 파일이면 true
 */
public static boolean isTextFile(String contentType) {
    // null 체크 후 MIME 타입 확인
    return contentType != null && contentType.toLowerCase().startsWith("text/");
}
```

**사용된 Java 메서드들:**
- `String.format(String, Object...)`: C 스타일의 printf 형태로 문자열 포맷팅하는 정적 메서드
- 포맷 지정자 `%.1f`: 소수점 첫째 자리까지 표시하는 부동소수점 형식

### 3.7 고급 보안 검증 메서드들
```java
/**
 * 파일명이 안전한지 검증합니다.
 * 
 * @param filename 파일명
 * @return 안전하면 true
 */
public static boolean isSafeFilename(String filename) {
    // null이나 빈 문자열 체크
    if (filename == null || filename.trim().isEmpty()) {
        return false;
    }
    
    // 위험한 패턴 확인 (정규표현식 매칭)
    if (DANGEROUS_FILENAME_PATTERN.matcher(filename).matches()) {
        return false; // 위험한 문자 포함
    }
    
    // 위험한 확장자 확인
    if (isDangerousExtension(filename)) {
        return false; // 실행 파일 확장자
    }
    
    // Windows 예약어 확인
    String nameWithoutExt = getFileNameWithoutExtension(filename).toUpperCase();
    String[] reservedNames = {"CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", 
                            "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", 
                            "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"};
    
    // 예약어와 비교
    for (String reserved : reservedNames) {
        if (reserved.equals(nameWithoutExt)) {
            return false; // Windows 예약어 사용
        }
    }
    
    return true; // 모든 검증 통과
}
```

**사용된 Java 메서드들:**
- `Pattern.matcher(String)`: 정규표현식 패턴과 문자열을 매칭하는 Matcher 객체 생성
- `Matcher.matches()`: 전체 문자열이 패턴과 일치하는지 확인
- `toUpperCase()`: 문자열을 대문자로 변환

### 3.8 날짜/시간 및 임시 파일 유틸리티들
```java
/**
 * 현재 시각으로 타임스탬프를 생성합니다.
 * 
 * @return yyyyMMdd_HHmmss 형태의 타임스탬프
 */
private static String generateTimestamp() {
    // 현재 날짜/시간을 지정된 형식으로 포맷
    return LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss"));
}

/**
 * 임시 파일을 생성합니다.
 * 
 * @param prefix 파일명 접두사
 * @param suffix 파일명 접미사
 * @return 생성된 임시 파일
 * @throws IOException 파일 생성 실패시
 */
public static File createTempFile(String prefix, String suffix) throws IOException {
    // 시스템 임시 디렉토리에 임시 파일 생성
    return File.createTempFile(prefix != null ? prefix : "upload", suffix);
}
```

**사용된 Java 메서드들:**
- `LocalDateTime.now()`: 현재 시스템의 날짜와 시간을 반환하는 정적 메서드
- `DateTimeFormatter.ofPattern(String)`: 지정된 패턴으로 날짜/시간 포맷터를 생성하는 정적 메서드
- `format(DateTimeFormatter)`: LocalDateTime을 지정된 형식의 문자열로 변환
- `File.createTempFile(String, String)`: 시스템 임시 디렉토리에 임시 파일을 생성하는 정적 메서드

---

## 주요 Java 개념 및 디자인 패턴 완전 정리

### 1. 정적 유틸리티 클래스 패턴 (Static Utility Class Pattern)
- **특징**: 모든 메서드가 `static`으로 선언되어 인스턴스 생성 없이 사용
- **장점**: 메모리 효율성, 전역적 접근 가능
- **구현**: private 생성자로 인스턴스화 방지

### 2. 빌더/플루언트 인터페이스 패턴 (Builder/Fluent Interface Pattern)
- **특징**: 메서드 체이닝을 통한 연속적인 설정
- **구현**: 모든 setter 메서드가 `return this;`로 자신을 반환
- **장점**: 가독성 높은 설정 코드, 불변 객체 생성 지원

### 3. 방어적 프로그래밍 (Defensive Programming)
- **null 안전성**: 모든 입력에 대한 null 체크
- **경계값 검증**: 크기, 범위 등의 유효성 검사
- **예외 처리**: 적절한 예외 타입과 메시지 제공

### 4. 보안 고려사항 (Security Considerations)
- **파일명 정리**: 위험한 문자 제거 및 경로 조작 방지
- **확장자 검증**: 실행 파일 및 위험한 확장자 차단
- **크기 제한**: 메모리 고갈 및 DoS 공격 방지

### 5. 정규표현식 활용 (Regular Expression Usage)
- **패턴 컴파일**: `Pattern.compile()`로 성능 최적화
- **문자열 치환**: `replaceAll()`로 위험 요소 제거
- **보안 검증**: 악성 패턴 탐지

### 6. 파일 시스템 API (File System API)
- **NIO.2 API**: `Path`, `Files` 클래스를 통한 현대적 파일 처리
- **크로스 플랫폼**: OS 독립적인 경로 처리
- **예외 처리**: IOException을 통한 적절한 오류 처리

---

## 4. 추가 유틸리티 메서드들 및 고급 기능

### 4.1 파일 검증 확장 메서드들

```java
/**
 * MIME 타입을 기반으로 파일 카테고리를 판단합니다.
 * 
 * @param contentType MIME 타입
 * @return 파일 카테고리 (IMAGE, DOCUMENT, AUDIO, VIDEO, ARCHIVE, OTHER)
 */
public static FileCategory getFileCategory(String contentType) {
    if (contentType == null) {
        return FileCategory.OTHER; // null이면 기타로 분류
    }
    
    String lowerType = contentType.toLowerCase(); // 대소문자 통일
    
    // 각 카테고리별 MIME 타입 확인
    if (lowerType.startsWith("image/")) {
        return FileCategory.IMAGE; // 이미지 파일
    } else if (lowerType.startsWith("text/") || 
               lowerType.equals("application/pdf") ||
               lowerType.startsWith("application/msword") ||
               lowerType.startsWith("application/vnd.openxmlformats-officedocument")) {
        return FileCategory.DOCUMENT; // 문서 파일
    } else if (lowerType.startsWith("audio/")) {
        return FileCategory.AUDIO; // 오디오 파일
    } else if (lowerType.startsWith("video/")) {
        return FileCategory.VIDEO; // 비디오 파일
    } else if (lowerType.equals("application/zip") ||
               lowerType.equals("application/x-rar-compressed") ||
               lowerType.equals("application/x-7z-compressed")) {
        return FileCategory.ARCHIVE; // 압축 파일
    } else {
        return FileCategory.OTHER; // 기타 파일
    }
}

/**
 * 파일의 마법 넘버(Magic Number)를 확인하여 실제 파일 타입을 검증합니다.
 * 
 * @param fileBytes 파일의 바이트 배열
 * @return 검증된 파일 타입, 알 수 없으면 null
 */
public static String validateFileTypeByMagicNumber(byte[] fileBytes) {
    if (fileBytes == null || fileBytes.length < 4) {
        return null; // 바이트가 충분하지 않으면 검증 불가
    }
    
    // 파일 시그니처 검사 (처음 몇 바이트로 파일 타입 판단)
    
    // JPEG 파일: FF D8 FF
    if (fileBytes.length >= 3 && 
        (fileBytes[0] & 0xFF) == 0xFF && 
        (fileBytes[1] & 0xFF) == 0xD8 && 
        (fileBytes[2] & 0xFF) == 0xFF) {
        return "image/jpeg";
    }
    
    // PNG 파일: 89 50 4E 47 0D 0A 1A 0A
    if (fileBytes.length >= 8 &&
        (fileBytes[0] & 0xFF) == 0x89 && 
        (fileBytes[1] & 0xFF) == 0x50 && 
        (fileBytes[2] & 0xFF) == 0x4E && 
        (fileBytes[3] & 0xFF) == 0x47 &&
        (fileBytes[4] & 0xFF) == 0x0D && 
        (fileBytes[5] & 0xFF) == 0x0A && 
        (fileBytes[6] & 0xFF) == 0x1A && 
        (fileBytes[7] & 0xFF) == 0x0A) {
        return "image/png";
    }
    
    // GIF 파일: 47 49 46 38 (GIF8)
    if (fileBytes.length >= 4 &&
        (fileBytes[0] & 0xFF) == 0x47 && 
        (fileBytes[1] & 0xFF) == 0x49 && 
        (fileBytes[2] & 0xFF) == 0x46 && 
        (fileBytes[3] & 0xFF) == 0x38) {
        return "image/gif";
    }
    
    // PDF 파일: 25 50 44 46 (%PDF)
    if (fileBytes.length >= 4 &&
        (fileBytes[0] & 0xFF) == 0x25 && 
        (fileBytes[1] & 0xFF) == 0x50 && 
        (fileBytes[2] & 0xFF) == 0x44 && 
        (fileBytes[3] & 0xFF) == 0x46) {
        return "application/pdf";
    }
    
    // ZIP 파일: 50 4B 03 04 또는 50 4B 05 06 또는 50 4B 07 08
    if (fileBytes.length >= 4 &&
        (fileBytes[0] & 0xFF) == 0x50 && 
        (fileBytes[1] & 0xFF) == 0x4B &&
        ((fileBytes[2] & 0xFF) == 0x03 || (fileBytes[2] & 0xFF) == 0x05 || (fileBytes[2] & 0xFF) == 0x07)) {
        return "application/zip";
    }
    
    return null; // 알려진 타입이 아님
}
```

**사용된 Java 개념들:**
- **비트 연산**: `& 0xFF`로 바이트를 unsigned로 변환
- **매직 넘버**: 파일 시작 부분의 고유한 바이트 시퀀스로 파일 타입 식별
- **열거형**: `FileCategory` enum을 통한 타입 안전한 분류

### 4.2 고급 파일명 처리 메서드들

```java
/**
 * 중복 파일명 처리를 위한 번호 추가 메서드입니다.
 * 
 * @param uploadDir 업로드 디렉토리
 * @param filename 원본 파일명
 * @return 중복되지 않는 파일명
 */
public static String generateNonDuplicateFileName(String uploadDir, String filename) {
    // 기본 파일 경로 생성
    String basePath = createSafeFilePath(uploadDir, filename);
    File baseFile = new File(basePath);
    
    // 파일이 존재하지 않으면 원본 파일명 그대로 사용
    if (!baseFile.exists()) {
        return filename;
    }
    
    // 파일명과 확장자 분리
    String nameWithoutExt = getFileNameWithoutExtension(filename);
    String extension = getFileExtension(filename);
    
    int counter = 1; // 중복 번호 카운터
    String newFileName;
    File newFile;
    
    // 중복되지 않는 파일명을 찾을 때까지 반복
    do {
        // "파일명(번호).확장자" 형태로 생성
        newFileName = nameWithoutExt + "(" + counter + ")" + extension;
        String newPath = createSafeFilePath(uploadDir, newFileName);
        newFile = new File(newPath);
        counter++; // 다음 번호로 증가
    } while (newFile.exists()); // 파일이 존재하는 동안 계속
    
    return newFileName; // 중복되지 않는 파일명 반환
}

/**
 * 파일명의 길이를 제한하여 OS 호환성을 보장합니다.
 * 
 * @param filename 원본 파일명
 * @param maxLength 최대 길이 (기본값: 255)
 * @return 길이가 제한된 파일명
 */
public static String limitFileNameLength(String filename, int maxLength) {
    if (filename == null || filename.length() <= maxLength) {
        return filename; // 제한 길이 내면 그대로 반환
    }
    
    // 확장자 분리
    String extension = getFileExtension(filename);
    String nameWithoutExt = getFileNameWithoutExtension(filename);
    
    // 확장자를 제외한 이름 부분의 최대 길이 계산
    int maxNameLength = maxLength - extension.length();
    
    if (maxNameLength <= 0) {
        // 확장자가 너무 길면 타임스탬프 사용
        return generateTimestamp() + extension;
    }
    
    // 이름 부분을 최대 길이로 잘라내기
    String truncatedName = nameWithoutExt.substring(0, Math.min(nameWithoutExt.length(), maxNameLength));
    
    return truncatedName + extension;
}

/**
 * 파일명을 URL 안전한 형태로 변환합니다.
 * 
 * @param filename 원본 파일명
 * @return URL 인코딩된 파일명
 */
public static String makeFileNameUrlSafe(String filename) {
    if (filename == null || filename.trim().isEmpty()) {
        return "file_" + System.currentTimeMillis();
    }
    
    try {
        // UTF-8로 URL 인코딩 수행
        return URLEncoder.encode(filename, StandardCharsets.UTF_8.toString())
                        .replace("+", "%20"); // 공백을 %20으로 변환 (+ 대신)
    } catch (UnsupportedEncodingException e) {
        // UTF-8은 항상 지원되므로 이 예외는 발생하지 않음
        return sanitizeFileName(filename); // 폴백으로 기본 정리 수행
    }
}
```

**사용된 Java 메서드들:**
- `File(String)`: 파일 경로를 나타내는 File 객체 생성자
- `exists()`: 파일이나 디렉토리의 존재 여부를 확인하는 메서드
- `do-while`: 조건을 나중에 확인하는 반복문 (최소 1회 실행 보장)
- `Math.min(int, int)`: 두 값 중 작은 값을 반환하는 정적 메서드
- `URLEncoder.encode(String, String)`: URL 인코딩을 수행하는 정적 메서드
- `UnsupportedEncodingException`: 지원되지 않는 인코딩 예외

### 4.3 파일 스트림 및 I/O 처리 메서드들

```java
/**
 * 파일을 안전하게 저장합니다.
 * 
 * @param fileContent 파일 내용 (바이트 배열)
 * @param uploadDir 업로드 디렉토리
 * @param filename 저장할 파일명
 * @param config 업로드 설정
 * @return 저장된 파일의 절대 경로
 * @throws IOException 저장 실패시
 */
public static String saveFile(byte[] fileContent, String uploadDir, String filename, UploadConfig config) 
        throws IOException {
    
    // 1. 디렉토리 존재 확인 및 생성
    if (config.isCreateUploadDir()) {
        ensureDirectoryExists(uploadDir);
    }
    
    // 2. 안전한 파일명 생성
    String safeFileName = sanitizeFileName(filename);
    
    // 3. 중복 파일명 처리
    if (!config.isOverwriteExisting()) {
        safeFileName = generateNonDuplicateFileName(uploadDir, safeFileName);
    }
    
    // 4. 최종 파일 경로 생성
    Path filePath = Paths.get(uploadDir, safeFileName);
    
    // 5. 파일 저장 (원자적 쓰기 작업)
    Files.write(filePath, fileContent, StandardOpenOption.CREATE, StandardOpenOption.WRITE);
    
    // 6. 절대 경로 반환
    return filePath.toAbsolutePath().toString();
}

/**
 * InputStream에서 바이트 배열로 안전하게 읽어옵니다.
 * 
 * @param inputStream 입력 스트림
 * @param maxSize 최대 읽기 크기 (메모리 보호)
 * @return 읽어온 바이트 배열
 * @throws IOException 읽기 실패시
 */
public static byte[] readInputStream(InputStream inputStream, long maxSize) throws IOException {
    // ByteArrayOutputStream을 사용하여 동적 크기 조절
    try (ByteArrayOutputStream baos = new ByteArrayOutputStream()) {
        byte[] buffer = new byte[8192]; // 8KB 버퍼
        int totalRead = 0; // 총 읽은 바이트 수
        int bytesRead;
        
        // 스트림에서 버퍼 크기만큼 반복적으로 읽기
        while ((bytesRead = inputStream.read(buffer)) != -1) {
            totalRead += bytesRead;
            
            // 최대 크기 초과 확인 (메모리 보호)
            if (totalRead > maxSize) {
                throw new IOException("File size exceeds maximum allowed size: " + maxSize + " bytes");
            }
            
            // 읽은 데이터를 출력 스트림에 쓰기
            baos.write(buffer, 0, bytesRead);
        }
        
        return baos.toByteArray(); // 바이트 배열로 변환하여 반환
    }
    // try-with-resources로 자동 리소스 해제
}

/**
 * 파일의 체크섬을 계산합니다. (무결성 검증용)
 * 
 * @param fileContent 파일 내용
 * @param algorithm 해시 알고리즘 (MD5, SHA-1, SHA-256 등)
 * @return 16진수 문자열로 된 체크섬
 * @throws NoSuchAlgorithmException 알고리즘을 찾을 수 없을 때
 */
public static String calculateChecksum(byte[] fileContent, String algorithm) throws NoSuchAlgorithmException {
    // 지정된 알고리즘의 MessageDigest 인스턴스 생성
    MessageDigest digest = MessageDigest.getInstance(algorithm);
    
    // 파일 내용을 해시 처리
    byte[] hashBytes = digest.digest(fileContent);
    
    // 바이트 배열을 16진수 문자열로 변환
    StringBuilder hexString = new StringBuilder();
    for (byte b : hashBytes) {
        // 각 바이트를 2자리 16진수로 변환 (앞에 0 패딩)
        String hex = Integer.toHexString(0xff & b);
        if (hex.length() == 1) {
            hexString.append('0'); // 한 자리면 앞에 0 추가
        }
        hexString.append(hex);
    }
    
    return hexString.toString(); // 최종 체크섬 문자열 반환
}
```

**사용된 Java 메서드들:**
- `Files.write(Path, byte[], OpenOption...)`: 파일에 바이트 배열을 쓰는 정적 메서드
- `StandardOpenOption.CREATE`: 파일이 없으면 생성하는 옵션
- `StandardOpenOption.WRITE`: 쓰기 모드로 파일을 여는 옵션
- `toAbsolutePath()`: 상대 경로를 절대 경로로 변환하는 메서드
- `ByteArrayOutputStream()`: 메모리에 바이트를 쓸 수 있는 출력 스트림
- `read(byte[])`: InputStream에서 바이트 배열로 읽는 메서드
- `write(byte[], int, int)`: 지정된 범위의 바이트를 쓰는 메서드
- `toByteArray()`: ByteArrayOutputStream의 내용을 바이트 배열로 변환
- `MessageDigest.getInstance(String)`: 해시 알고리즘 인스턴스를 얻는 정적 메서드
- `digest(byte[])`: 바이트 배열을 해시 처리하는 메서드
- `Integer.toHexString(int)`: 정수를 16진수 문자열로 변환하는 정적 메서드

### 4.4 고급 검증 및 보안 메서드들

```java
/**
 * 파일 내용을 스캔하여 악성 패턴을 탐지합니다.
 * 
 * @param fileContent 파일 내용
 * @param filename 파일명
 * @return 스캔 결과 (안전하면 true)
 */
public static boolean scanForMaliciousContent(byte[] fileContent, String filename) {
    // 1. 스크립트 태그 탐지 (웹 업로드시 XSS 방지)
    String content = new String(fileContent, StandardCharsets.UTF_8);
    String lowerContent = content.toLowerCase();
    
    // 위험한 HTML/JavaScript 패턴들
    String[] dangerousPatterns = {
        "<script", "javascript:", "vbscript:", "onload=", "onerror=", 
        "onclick=", "onmouseover=", "<iframe", "<object", "<embed"
    };
    
    for (String pattern : dangerousPatterns) {
        if (lowerContent.contains(pattern)) {
            return false; // 위험한 패턴 발견
        }
    }
    
    // 2. 실행 파일 시그니처 탐지
    if (hasExecutableSignature(fileContent)) {
        return false; // 실행 파일 시그니처 발견
    }
    
    // 3. 파일 크기 대비 내용 검증 (압축 폭탄 공격 탐지)
    if (isPotentialZipBomb(fileContent, filename)) {
        return false; // 잠재적 압축 폭탄
    }
    
    return true; // 모든 검사 통과
}

/**
 * 실행 파일 시그니처를 탐지합니다.
 * 
 * @param fileContent 파일 내용
 * @return 실행 파일이면 true
 */
private static boolean hasExecutableSignature(byte[] fileContent) {
    if (fileContent.length < 2) {
        return false;
    }
    
    // DOS 실행 파일 시그니처: "MZ"
    if (fileContent[0] == 0x4D && fileContent[1] == 0x5A) {
        return true; // PE/DOS 실행 파일
    }
    
    // ELF 실행 파일 시그니처: 0x7F + "ELF"
    if (fileContent.length >= 4 &&
        fileContent[0] == 0x7F && 
        fileContent[1] == 0x45 && 
        fileContent[2] == 0x4C && 
        fileContent[3] == 0x46) {
        return true; // Linux 실행 파일
    }
    
    return false;
}

/**
 * 압축 폭탄 공격 가능성을 탐지합니다.
 * 
 * @param fileContent 파일 내용
 * @param filename 파일명
 * @return 압축 폭탄 가능성이 있으면 true
 */
private static boolean isPotentialZipBomb(byte[] fileContent, String filename) {
    // ZIP 파일인 경우에만 검사
    String extension = getFileExtension(filename);
    if (!".zip".equals(extension)) {
        return false; // ZIP 파일이 아니면 안전
    }
    
    // 기본적인 압축 비율 검사
    // 실제 구현에서는 압축 해제 없이 ZIP 헤더 정보만으로 판단
    // 여기서는 단순한 휴리스틱 사용
    if (fileContent.length < 1000 && filename.toLowerCase().contains("bomb")) {
        return true; // 의심스러운 작은 ZIP 파일
    }
    
    return false; // 일반적인 파일로 판단
}

/**
 * 업로드된 파일의 전체적인 보안 검증을 수행합니다.
 * 
 * @param multipartFile 업로드된 파일
 * @param config 업로드 설정
 * @return 검증 결과 객체
 */
public static FileValidationResult validateUploadedFile(MultipartFile multipartFile, UploadConfig config) {
    List<String> errors = new ArrayList<>(); // 오류 목록
    List<String> warnings = new ArrayList<>(); // 경고 목록
    
    // 1. 파일 존재 여부 확인
    if (multipartFile == null || multipartFile.isEmpty()) {
        errors.add("File is empty or null");
        return new FileValidationResult(false, errors, warnings);
    }
    
    // 2. 파일 크기 검증
    long fileSize = multipartFile.getSize();
    if (!isValidFileSize(fileSize, config.getMaxFileSize())) {
        errors.add("File size (" + formatFileSize(fileSize) + 
                  ") exceeds maximum allowed size (" + formatFileSize(config.getMaxFileSize()) + ")");
    }
    
    // 3. 파일명 안전성 검증
    String filename = multipartFile.getOriginalFilename();
    if (!isSafeFilename(filename)) {
        errors.add("Filename contains unsafe characters: " + filename);
    }
    
    // 4. 확장자 검증
    if (!isAllowedExtension(filename, config.getAllowedExtensions())) {
        errors.add("File extension not allowed: " + getFileExtension(filename));
    }
    
    // 5. MIME 타입 검증
    String contentType = multipartFile.getContentType();
    if (contentType != null) {
        try {
            byte[] fileContent = multipartFile.getBytes();
            String detectedType = validateFileTypeByMagicNumber(fileContent);
            
            if (detectedType != null && !detectedType.equals(contentType)) {
                warnings.add("MIME type mismatch: declared=" + contentType + ", detected=" + detectedType);
            }
            
            // 6. 악성 내용 스캔
            if (!scanForMaliciousContent(fileContent, filename)) {
                errors.add("File contains potentially malicious content");
            }
            
        } catch (IOException e) {
            errors.add("Unable to read file content for validation");
        }
    }
    
    // 결과 반환
    boolean isValid = errors.isEmpty();
    return new FileValidationResult(isValid, errors, warnings);
}
```

**사용된 Java 메서드들:**
- `String(byte[], Charset)`: 바이트 배열을 지정된 문자셋으로 문자열 변환하는 생성자
- `isEmpty()`: MultipartFile이 비어있는지 확인하는 메서드
- `getSize()`: MultipartFile의 크기를 반환하는 메서드
- `getOriginalFilename()`: 원본 파일명을 반환하는 메서드
- `getContentType()`: MIME 타입을 반환하는 메서드
- `getBytes()`: MultipartFile의 내용을 바이트 배열로 반환하는 메서드

---

## 5. 완전한 사용 예제 및 통합 시나리오

### 5.1 기본 사용 예제

```java
// 1. 설정 생성 및 구성
UploadConfig config = new UploadConfig()
    .setUploadDir("/var/uploads")           // 업로드 디렉토리 설정
    .setMaxFileSizeMB(10)                   // 최대 파일 크기 10MB
    .setMaxRequestSizeMB(50)                // 최대 요청 크기 50MB
    .allowImagesOnly()                      // 이미지만 허용
    .setCreateUploadDir(true)               // 디렉토리 자동 생성
    .setOverwriteExisting(false);           // 중복 파일 방지

// 2. HTTP 요청 파싱
try {
    MultipartRequest multipartRequest = MultipartParser.parseRequest(httpRequest);
    
    // 3. 업로드된 파일들 처리
    Map<String, List<MultipartFile>> files = multipartRequest.getFiles();
    
    for (Map.Entry<String, List<MultipartFile>> entry : files.entrySet()) {
        String fieldName = entry.getKey();
        List<MultipartFile> fileList = entry.getValue();
        
        for (MultipartFile file : fileList) {
            // 4. 파일 검증
            FileValidationResult result = FileUploadUtil.validateUploadedFile(file, config);
            
            if (result.isValid()) {
                // 5. 파일 저장
                String savedPath = FileUploadUtil.saveFile(
                    file.getBytes(),
                    config.getUploadDir(),
                    file.getOriginalFilename(),
                    config
                );
                
                System.out.println("File saved: " + savedPath);
            } else {
                System.err.println("File validation failed: " + result.getErrors());
            }
        }
    }
    
} catch (IOException e) {
    System.err.println("Upload processing failed: " + e.getMessage());
}
```

### 5.2 고급 활용 시나리오

```java
/**
 * 웹 애플리케이션에서의 완전한 파일 업로드 처리 예제
 */
public class FileUploadController {
    
    private final UploadConfig defaultConfig;
    private final Map<String, UploadConfig> configByType;
    
    public FileUploadController() {
        // 기본 설정
        this.defaultConfig = new UploadConfig()
            .setUploadDir("./uploads/general")
            .setMaxFileSizeMB(5)
            .allowAllFiles();
        
        // 타입별 특별 설정
        this.configByType = new HashMap<>();
        
        // 이미지 전용 설정
        configByType.put("images", new UploadConfig()
            .setUploadDir("./uploads/images")
            .setMaxFileSizeMB(20)
            .allowImagesOnly()
            .setOverwriteExisting(false));
        
        // 문서 전용 설정
        configByType.put("documents", new UploadConfig()
            .setUploadDir("./uploads/documents")
            .setMaxFileSizeMB(100)
            .allowDocumentsOnly()
            .setCreateUploadDir(true));
    }
    
    /**
     * 파일 업로드 처리 메인 메서드
     */
    public UploadResponse handleFileUpload(HttpRequest request, String uploadType) {
        try {
            // 1. 설정 선택
            UploadConfig config = configByType.getOrDefault(uploadType, defaultConfig);
            
            // 2. 요청 파싱
            MultipartRequest multipartRequest = MultipartParser.parseRequest(request);
            
            // 3. 업로드 결과 저장
            List<UploadedFileInfo> uploadedFiles = new ArrayList<>();
            List<String> errors = new ArrayList<>();
            
            // 4. 각 파일 처리
            Map<String, List<MultipartFile>> files = multipartRequest.getFiles();
            for (Map.Entry<String, List<MultipartFile>> entry : files.entrySet()) {
                String fieldName = entry.getKey();
                
                for (MultipartFile file : entry.getValue()) {
                    try {
                        UploadedFileInfo info = processIndividualFile(file, config, fieldName);
                        uploadedFiles.add(info);
                    } catch (Exception e) {
                        errors.add("Failed to process file '" + file.getOriginalFilename() + "': " + e.getMessage());
                    }
                }
            }
            
            // 5. 결과 반환
            return new UploadResponse(uploadedFiles, errors);
            
        } catch (Exception e) {
            return new UploadResponse(Collections.emptyList(), 
                                    Arrays.asList("Upload processing failed: " + e.getMessage()));
        }
    }
    
    /**
     * 개별 파일 처리
     */
    private UploadedFileInfo processIndividualFile(MultipartFile file, UploadConfig config, String fieldName) 
            throws IOException, NoSuchAlgorithmException {
        
        // 1. 파일 검증
        FileValidationResult validation = FileUploadUtil.validateUploadedFile(file, config);
        if (!validation.isValid()) {
            throw new IllegalArgumentException("File validation failed: " + validation.getErrors());
        }
        
        // 2. 고유 파일명 생성
        String originalFilename = file.getOriginalFilename();
        String uniqueFilename = FileUploadUtil.generateUniqueFileName(originalFilename);
        
        // 3. 파일 저장
        String savedPath = FileUploadUtil.saveFile(
            file.getBytes(),
            config.getUploadDir(),
            uniqueFilename,
            config
        );
        
        // 4. 메타데이터 생성
        byte[] fileContent = file.getBytes();
        String checksum = FileUploadUtil.calculateChecksum(fileContent, "SHA-256");
        FileCategory category = FileUploadUtil.getFileCategory(file.getContentType());
        
        // 5. 파일 정보 객체 생성
        return new UploadedFileInfo(
            fieldName,                              // 폼 필드명
            originalFilename,                       // 원본 파일명
            uniqueFilename,                         // 저장된 파일명
            savedPath,                              // 저장 경로
            file.getSize(),                         // 파일 크기
            file.getContentType(),                  // MIME 타입
            checksum,                               // 체크섬
            category,                               // 파일 카테고리
            System.currentTimeMillis(),             // 업로드 시간
            validation.getWarnings()                // 검증 경고
        );
    }
}
```

**이 완전한 분석에서 다룬 주요 Java 개념들:**

1. **컬렉션 프레임워크**: HashMap, ArrayList, List, Map 등의 효율적 활용
2. **스트림 처리**: InputStream, OutputStream을 통한 안전한 파일 I/O
3. **예외 처리**: try-catch-finally, try-with-resources를 통한 리소스 관리
4. **문자열 처리**: 정규표현식, 문자 인코딩, 패턴 매칭
5. **보안 고려사항**: 입력 검증, 경로 조작 방지, 악성 코드 탐지
6. **성능 최적화**: 버퍼 사용, 스트림 처리, 메모리 효율성
7. **디자인 패턴**: 유틸리티 클래스, 빌더 패턴, 팩토리 메서드
8. **파일 시스템**: NIO.2 API를 통한 현대적 파일 처리
9. **암호화**: 해시 함수를 통한 무결성 검증
10. **멀티 플랫폼**: OS 독립적인 파일 처리 구현

이 시스템은 엔터프라이즈급 웹 애플리케이션에서 요구되는 모든 파일 업로드 기능을 안전하고 효율적으로 처리할 수 있는 완전한 솔루션입니다.