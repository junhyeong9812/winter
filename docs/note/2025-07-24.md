# 📘 TypeConverter 상세 분석 및 메서드 설명

## 🔍 주요 메서드 상세 분석

### 1. `java.lang.reflect.Array.newInstance(componentType, 0)`

#### 📋 코드 블럭:
```java
if (value == null || value.trim().isEmpty()) {
    return java.lang.reflect.Array.newInstance(componentType, 0);
}
```

#### 🎯 **기능**:
- **리플렉션을 사용하여 배열을 동적으로 생성**하는 메서드
- 컴파일 타임에 배열 타입을 알 수 없을 때 사용

#### 📖 **메서드 시그니처**:
```java
public static Object newInstance(Class<?> componentType, int length)
```

#### 🔧 **파라미터**:
- `componentType`: 배열의 **요소 타입** (String.class, Integer.class 등)
- `length`: 배열의 **크기**

#### 💡 **동작 플로우**:
```java
// 예시: String[] 배열을 크기 0으로 생성
Class<?> componentType = String.class;
Object emptyArray = Array.newInstance(componentType, 0);
// 결과: new String[0] 과 동일

// 예시: Integer[] 배열을 크기 3으로 생성  
Object intArray = Array.newInstance(Integer.class, 3);
// 결과: new Integer[3] 과 동일
```

#### 🌟 **왜 사용하는가?**:
```java
// 일반적인 방법 (컴파일 타임에 타입을 알 때)
String[] stringArray = new String[5];
Integer[] intArray = new Integer[3];

// 리플렉션 방법 (런타임에 타입을 결정할 때)
Class<?> unknownType = getTypeFromSomewhere(); // String.class 또는 Integer.class
Object dynamicArray = Array.newInstance(unknownType, 5);
// unknownType이 String.class면 → new String[5]
// unknownType이 Integer.class면 → new Integer[5]
```

---

### 2. `java.lang.reflect.Array.set(array, i, convertedValue)`

#### 📋 코드 블럭:
```java
for (int i = 0; i < parts.length; i++) {
    String part = parts[i].trim();
    Object convertedValue = convert(part, componentType);
    java.lang.reflect.Array.set(array, i, convertedValue);
}
```

#### 🎯 **기능**:
- **리플렉션으로 생성된 배열의 특정 인덱스에 값을 설정**하는 메서드

#### 📖 **메서드 시그니처**:
```java
public static void set(Object array, int index, Object value)
```

#### 🔧 **파라미터**:
- `array`: 값을 설정할 **배열 객체**
- `index`: 설정할 **인덱스 위치**
- `value`: 설정할 **값**

#### 💡 **동작 플로우**:
```java
// 1. 배열 생성
Object stringArray = Array.newInstance(String.class, 3);

// 2. 값 설정
Array.set(stringArray, 0, "첫번째");  // stringArray[0] = "첫번째"
Array.set(stringArray, 1, "두번째");  // stringArray[1] = "두번째"  
Array.set(stringArray, 2, "세번째");  // stringArray[2] = "세번째"

// 3. 결과: ["첫번째", "두번째", "세번째"]
```

#### 🌟 **일반 배열 접근과 비교**:
```java
// 일반적인 방법
String[] normalArray = new String[3];
normalArray[0] = "값1";  // 직접 접근

// 리플렉션 방법  
Object reflectionArray = Array.newInstance(String.class, 3);
Array.set(reflectionArray, 0, "값1");  // 리플렉션 접근
```

---

### 3. `convert(part, componentType)` 재귀 호출

#### 📋 코드 블럭:
```java
for (int i = 0; i < parts.length; i++) {
    String part = parts[i].trim();
    Object convertedValue = convert(part, componentType);  // 재귀 호출
    java.lang.reflect.Array.set(array, i, convertedValue);
}
```

#### 🎯 **기능**:
- **자기 자신을 재귀적으로 호출**하여 배열의 각 요소를 변환

#### 💡 **동작 플로우**:
```java
// 시나리오: "1,2,3" → Integer[] 변환

// 1. convertArray 메서드에서
String[] parts = "1,2,3".split(",");  // ["1", "2", "3"]
Class<?> componentType = Integer.class;

// 2. 각 요소를 변환
for (int i = 0; i < parts.length; i++) {
    String part = parts[i].trim();           // "1", "2", "3"
    
    // 3. convert 메서드를 재귀 호출
    Object convertedValue = convert(part, componentType);
    // convert("1", Integer.class) → 1 (Integer)
    // convert("2", Integer.class) → 2 (Integer)
    // convert("3", Integer.class) → 3 (Integer)
    
    // 4. 배열에 저장
    Array.set(array, i, convertedValue);
}
// 최종 결과: [1, 2, 3] (Integer 배열)
```

#### 🔄 **재귀 호출의 이점**:
```java
// 재귀 호출을 사용하지 않는다면:
if (componentType == String.class) {
    Array.set(array, i, part);
} else if (componentType == Integer.class) {
    Array.set(array, i, Integer.parseInt(part));
} else if (componentType == Boolean.class) {
    Array.set(array, i, Boolean.parseBoolean(part));
}
// ... 모든 타입에 대해 중복 코드

// 재귀 호출을 사용하면:
Object convertedValue = convert(part, componentType);  // 기존 로직 재사용
Array.set(array, i, convertedValue);
```

---

### 4. `value.trim().isEmpty()`

#### 📋 코드 블럭:
```java
if (value == null || value.trim().isEmpty()) {
    return java.lang.reflect.Array.newInstance(componentType, 0);
}
```

#### 🎯 **기능**:
- **문자열의 공백을 제거한 후 빈 문자열인지 확인**

#### 📖 **메서드 체이닝**:
```java
String value = "  hello  ";
value.trim()      // "hello" (앞뒤 공백 제거)
     .isEmpty()   // false (빈 문자열이 아님)
```

#### 💡 **동작 플로우**:
```java
// 다양한 케이스
String case1 = "hello";     // trim() → "hello",    isEmpty() → false
String case2 = "  hello  "; // trim() → "hello",    isEmpty() → false  
String case3 = "";          // trim() → "",         isEmpty() → true
String case4 = "   ";       // trim() → "",         isEmpty() → true
String case5 = null;        // NullPointerException (trim() 호출 불가)

// 안전한 체크
if (value == null || value.trim().isEmpty()) {
    // null이거나 공백만 있는 경우
}
```

#### 🌟 **trim()의 중요성**:
```java
// trim() 없이 체크하면:
"   ".isEmpty()  // false (공백이 있으므로)

// trim() 후 체크하면:
"   ".trim().isEmpty()  // true (공백 제거 후 빈 문자열)

// HTTP 파라미터에서 자주 발생하는 상황:
// URL: /search?keyword=   (공백만 입력)
String keyword = request.getParameter("keyword");  // "   "
if (keyword.trim().isEmpty()) {
    // 실질적으로 빈 값으로 처리
}
```

---

### 5. `arrayType.getComponentType()`

#### 📋 코드 블럭:
```java
private static Object convertArray(String value, Class<?> arrayType) {
    Class<?> componentType = arrayType.getComponentType();
    // ...
}
```

#### 🎯 **기능**:
- **배열 타입에서 요소의 타입을 추출**하는 메서드

#### 📖 **메서드 시그니처**:
```java
public Class<?> getComponentType()
```

#### 💡 **동작 플로우**:
```java
// 다양한 배열 타입의 컴포넌트 타입
Class<?> stringArrayType = String[].class;
Class<?> componentType1 = stringArrayType.getComponentType();
// 결과: String.class

Class<?> intArrayType = int[].class;  
Class<?> componentType2 = intArrayType.getComponentType();
// 결과: int.class

Class<?> integerArrayType = Integer[].class;
Class<?> componentType3 = integerArrayType.getComponentType();  
// 결과: Integer.class

// 배열이 아닌 타입의 경우
Class<?> stringType = String.class;
Class<?> componentType4 = stringType.getComponentType();
// 결과: null (배열이 아니므로)
```

#### 🌟 **실제 사용 예시**:
```java
// 메서드 파라미터가 String[] 타입일 때
public void method(@RequestParam("tags") String[] tags) { ... }

// TypeConverter에서 처리:
Class<?> paramType = String[].class;           // 파라미터 타입
Class<?> elementType = paramType.getComponentType();  // String.class

// 이제 "java,spring,mvc"를 String[]로 변환:
// 1. split(",") → ["java", "spring", "mvc"]  
// 2. 각 요소를 String.class로 변환 (이미 String이므로 그대로)
// 3. String[] 배열에 저장
```

---

### 6. `CONVERTERS.containsKey(type)`

#### 📋 코드 블럭:
```java
public static boolean isSupported(Class<?> type) {
    return CONVERTERS.containsKey(type) || type.isArray();
}
```

#### 🎯 **기능**:
- **Map에 특정 키가 존재하는지 확인**하는 메서드

#### 📖 **Map 메서드**:
```java
boolean containsKey(Object key)  // 키 존재 여부 반환
```

#### 💡 **동작 플로우**:
```java
// CONVERTERS Map의 내용:
CONVERTERS.put(String.class, value -> value);
CONVERTERS.put(Integer.class, Integer::parseInt);
CONVERTERS.put(Boolean.class, Boolean::parseBoolean);

// containsKey 테스트:
boolean test1 = CONVERTERS.containsKey(String.class);   // true
boolean test2 = CONVERTERS.containsKey(Integer.class);  // true  
boolean test3 = CONVERTERS.containsKey(Date.class);     // false (등록 안됨)
boolean test4 = CONVERTERS.containsKey(null);           // false
```

#### 🌟 **사용 목적**:
```java
public static <T> T convert(String value, Class<T> targetType) {
    // 1. 지원하는 타입인지 먼저 확인
    Function<String, Object> converter = CONVERTERS.get(targetType);
    if (converter == null) {  // containsKey(targetType) == false와 동일
        throw new IllegalArgumentException("Unsupported type: " + targetType);
    }
    
    // 2. 변환 실행
    return (T) converter.apply(value);
}

// isSupported 메서드에서 미리 체크:
if (!TypeConverter.isSupported(targetType)) {
    throw new IllegalArgumentException("Cannot convert to " + targetType);
}
```

---

### 7. 삼항 연산자 `(condition) ? value1 : value2`

#### 📋 코드 블럭:
```java
String valueToConvert = (value == null || value.isEmpty()) ? defaultValue : value;
```

#### 🎯 **기능**:
- **조건에 따라 두 값 중 하나를 선택**하는 연산자 (if-else의 축약형)

#### 💡 **동작 플로우**:
```java
// 삼항 연산자 구조:
// (조건) ? 참일때값 : 거짓일때값

// 위 코드를 if-else로 쓰면:
String valueToConvert;
if (value == null || value.isEmpty()) {
    valueToConvert = defaultValue;  // 조건이 참이면
} else {
    valueToConvert = value;         // 조건이 거짓이면  
}

// 실제 예시:
String value = null;
String defaultValue = "10";
String result = (value == null || value.isEmpty()) ? defaultValue : value;
// 결과: "10" (value가 null이므로 defaultValue 선택)

String value2 = "5";  
String result2 = (value2 == null || value2.isEmpty()) ? defaultValue : value2;
// 결과: "5" (value2가 있으므로 value2 선택)
```

#### 🌟 **다양한 삼항 연산자 예시**:
```java
// 최댓값 구하기
int max = (a > b) ? a : b;

// null 체크
String name = (user != null) ? user.getName() : "Unknown";

// 문자열 길이 체크  
String message = (text.length() > 10) ? "Long text" : "Short text";

// 중첩 삼항 연산자 (권장하지 않음)
String grade = (score >= 90) ? "A" : (score >= 80) ? "B" : "C";
```

---

### 8. 제네릭 메서드 `<T>`

#### 📋 코드 블럭:
```java
public static <T> T convertWithDefault(String value, Class<T> targetType, String defaultValue) {
    // ...
    return (T) converter.apply(valueToConvert);
}
```

#### 🎯 **기능**:
- **메서드 레벨에서 제네릭 타입을 정의**하여 타입 안전성 보장

#### 💡 **동작 플로우**:
```java
// 제네릭 메서드 호출:
Integer result1 = convertWithDefault("123", Integer.class, "0");
// T = Integer, 반환타입도 Integer

String result2 = convertWithDefault(null, String.class, "default");  
// T = String, 반환타입도 String

Boolean result3 = convertWithDefault("", Boolean.class, "false");
// T = Boolean, 반환타입도 Boolean
```

#### 🌟 **제네릭 없이 쓴다면**:
```java
// 제네릭 없는 버전:
public static Object convertWithDefault(String value, Class<?> targetType, String defaultValue) {
    // ...
    return converter.apply(valueToConvert);  // Object 반환
}

// 사용할 때 캐스팅 필요:
Integer result = (Integer) convertWithDefault("123", Integer.class, "0");  // 캐스팅 필요
String result2 = (String) convertWithDefault(null, String.class, "default");  // 캐스팅 필요

// 제네릭 버전:
Integer result = convertWithDefault("123", Integer.class, "0");  // 캐스팅 불필요
String result2 = convertWithDefault(null, String.class, "default");  // 캐스팅 불필요
```

#### 🔍 **Class<T> vs Class<?>**:
```java
// Class<T>: 구체적인 타입과 연결
public static <T> T convert(String value, Class<T> targetType) {
    // targetType과 반환 타입이 같다고 보장
    return (T) result;  // 안전한 캐스팅
}

// Class<?>: 알 수 없는 타입
public static Object convert(String value, Class<?> targetType) {  
    // 반환 타입을 알 수 없음
    return result;  // Object로 반환
}
```

---

## 🔄 TypeConverter 전체 동작 플로우

### 시나리오 1: 단순 타입 변환
```java
// 호출: TypeConverter.convert("123", Integer.class)

1. convert 메서드 진입
   ├─ value = "123"
   ├─ targetType = Integer.class
   └─ 배열 타입인가? → false

2. CONVERTERS Map에서 변환기 찾기
   ├─ CONVERTERS.get(Integer.class)
   └─ 결과: Integer::parseInt 함수

3. 변환 실행
   ├─ converter.apply("123")
   ├─ Integer.parseInt("123") 실행
   └─ 결과: 123 (Integer 객체)

4. 반환: 123
```

### 시나리오 2: 배열 타입 변환
```java
// 호출: TypeConverter.convert("apple,banana,cherry", String[].class)

1. convert 메서드 진입
   ├─ value = "apple,banana,cherry"  
   ├─ targetType = String[].class
   └─ 배열 타입인가? → true

2. convertArray 메서드 호출
   ├─ arrayType.getComponentType() → String.class
   ├─ value.split(",") → ["apple", "banana", "cherry"]
   └─ Array.newInstance(String.class, 3) → 빈 String[3] 생성

3. 각 요소 변환 및 저장
   ├─ "apple".trim() → "apple"
   ├─ convert("apple", String.class) → "apple" (재귀 호출)
   ├─ Array.set(array, 0, "apple")
   ├─ (banana, cherry도 동일하게 처리)
   └─ 결과: ["apple", "banana", "cherry"]

4. 반환: String[] 배열
```

### 시나리오 3: 기본값이 있는 변환
```java
// 호출: TypeConverter.convertWithDefault(null, Integer.class, "100")

1. convertWithDefault 메서드 진입
   ├─ value = null
   ├─ targetType = Integer.class  
   └─ defaultValue = "100"

2. 사용할 값 결정
   ├─ (value == null || value.isEmpty()) ? defaultValue : value
   ├─ 조건: true (value가 null)
   └─ valueToConvert = "100"

3. 일반 변환 호출
   ├─ convert("100", Integer.class)
   ├─ Integer.parseInt("100")
   └─ 결과: 100

4. 반환: 100 (Integer)
```

---

## 🎯 **결론**

TypeConverter는 **리플렉션**, **함수형 프로그래밍**, **제네릭**, **삼항 연산자** 등 Java의 다양한 기능을 조합하여:

1. **타입 안전성** 보장 (제네릭)
2. **확장성** 제공 (Map 기반 전략 패턴)
3. **동적 배열 처리** (리플렉션)
4. **기본값 처리** (삼항 연산자)
5. **재사용성** (재귀 호출)

