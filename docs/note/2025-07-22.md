# TypeConverter 클래스 분석

## 개요
`TypeConverter` 클래스는 문자열을 다양한 Java 타입으로 변환하는 유틸리티 클래스입니다. 정적 맵을 사용하여 각 타입별 변환 함수를 저장하고 관리합니다.

## 코드 동작 분석

### 1. 클래스 구조
```java
public class TypeConverter {
    // 타입별 변환 함수를 저장하는 정적 맵
    private static final Map<Class<?>, Function<String, Object>> CONVERTERS = new HashMap<>();
    
    static {
        // 정적 초기화 블록에서 변환기들을 등록
    }
}
```

### 2. 변환기 등록 과정 (static 블록)

#### 문자열 타입
```java
CONVERTERS.put(String.class, value -> value);
```
- **동작**: 입력 문자열을 그대로 반환
- **람다식**: `value -> value` (항등 함수)

#### 정수 타입 (int/Integer)
```java
CONVERTERS.put(int.class, Integer::parseInt);
CONVERTERS.put(Integer.class, value -> value.isEmpty() ? null : Integer.parseInt(value));
```
- **int**: 메서드 참조 `Integer::parseInt` 사용
- **Integer**: 빈 문자열이면 null 반환, 아니면 파싱

#### 긴 정수 타입 (long/Long)
```java
CONVERTERS.put(long.class, Long::parseLong);
CONVERTERS.put(Long.class, value -> value.isEmpty() ? null : Long.parseLong(value));
```
- **long**: 메서드 참조 `Long::parseLong` 사용
- **Long**: 빈 문자열 처리 후 파싱

#### 실수 타입 (double/Double)
```java
CONVERTERS.put(double.class, Double::parseDouble);
CONVERTERS.put(Double.class, value -> value.isEmpty() ? null : Double.parseDouble(value));
```
- **double**: 메서드 참조 `Double::parseDouble` 사용
- **Double**: 빈 문자열 처리 후 파싱

#### 부울 타입 (boolean/Boolean)
```java
CONVERTERS.put(boolean.class, Boolean::parseBoolean);
CONVERTERS.put(Boolean.class, value -> value.isEmpty() ? null : Boolean.parseBoolean(value));
```
- **boolean**: 메서드 참조 `Boolean::parseBoolean` 사용
- **Boolean**: 빈 문자열 처리 후 파싱

#### 날짜 타입
```java
CONVERTERS.put(LocalDate.class, value -> {
    if (value == null || value.isEmpty()) return null;
    return LocalDate.parse(value, DateTimeFormatter.ISO_LOCAL_DATE); // yyyy-MM-dd
});

CONVERTERS.put(LocalDateTime.class, value -> {
    if (value == null || value.isEmpty()) return null;
    return LocalDateTime.parse(value, DateTimeFormatter.ISO_LOCAL_DATE_TIME); // yyyy-MM-ddTHH:mm:ss
});
```
- **LocalDate**: ISO 형식 (yyyy-MM-dd)으로 파싱
- **LocalDateTime**: ISO 형식 (yyyy-MM-ddTHH:mm:ss)으로 파싱
- 둘 다 null/빈 문자열 체크 포함

## 주요 개념 설명

### 1. 메서드 참조 (::) 표현
메서드 참조는 람다 표현식의 축약형입니다.

#### 정적 메서드 참조
```java
// 메서드 참조
Integer::parseInt

// 동일한 람다식
value -> Integer.parseInt(value)
```

#### 사용 예시
```java
Function<String, Integer> converter1 = Integer::parseInt;        // 메서드 참조
Function<String, Integer> converter2 = s -> Integer.parseInt(s); // 람다식
```

### 2. 람다식 `value -> Integer.parseInt(value)` 상세 분석

#### 기본 구조
```java
value -> Integer.parseInt(value)
```
- **`value`**: 람다식의 매개변수 (String 타입)
- **`->`**: 람다 연산자 (매개변수와 본문을 구분)
- **`Integer.parseInt(value)`**: 람다식의 본문 (실행할 코드)

#### Function 인터페이스와의 관계
```java
Function<String, Integer> converter = value -> Integer.parseInt(value);
```
- **Function<String, Integer>**: 함수형 인터페이스
    - 첫 번째 제네릭 `String`: 입력 타입
    - 두 번째 제네릭 `Integer`: 반환 타입
- **apply() 메서드**: `Integer apply(String input)`을 람다식으로 구현

#### 전통적인 방식과 비교
```java
// 1. 익명 클래스 방식 (Java 8 이전)
Function<String, Integer> converter1 = new Function<String, Integer>() {
    @Override
    public Integer apply(String value) {
        return Integer.parseInt(value);
    }
};

// 2. 람다식 방식 (Java 8+)
Function<String, Integer> converter2 = value -> Integer.parseInt(value);

// 3. 메서드 참조 방식 (Java 8+)
Function<String, Integer> converter3 = Integer::parseInt;
```

#### 실제 동작 과정
```java
// 1. 람다식 정의
Function<String, Integer> parser = value -> Integer.parseInt(value);

// 2. 람다식 실행
String input = "123";
Integer result = parser.apply(input);  // apply 메서드 호출

// 3. 내부적으로 다음과 같이 동작:
// value = "123"
// Integer.parseInt("123") 실행
// 결과: 123 (Integer 객체)
```

### 3. 람다 표현식의 다양한 패턴

### 3. 람다 표현식의 다양한 패턴

#### 매개변수의 타입 추론
```java
// 컴파일러가 타입을 추론하므로 생략 가능
Map<Class<?>, Function<String, Object>> map = new HashMap<>();

// 명시적 타입 (생략 가능)
map.put(Integer.class, (String value) -> Integer.parseInt(value));

// 타입 추론 (일반적)
map.put(Integer.class, value -> Integer.parseInt(value));
```
#### 조건부 처리 람다
```
- **구조**: `매개변수 -> 조건 ? 값1 : 값2`
- **의미**: 빈 문자열이면 null, 아니면 파싱 결과 반환

#### 멀티라인 람다
```java
value -> {
    if (value == null || value.isEmpty()) return null;
    return LocalDate.parse(value, DateTimeFormatter.ISO_LOCAL_DATE);
}
```
- **구조**: `매개변수 -> { 복수 명령문 }`
- **의미**: 복잡한 로직을 포함한 변환 처리

### 4. TypeConverter 패턴의 장점

#### 확장성
```java
// 새로운 타입 추가가 쉬움
CONVERTERS.put(BigDecimal.class, value -> 
    value.isEmpty() ? null : new BigDecimal(value));
```

#### 타입 안전성
```java
Function<String, Object> converter = CONVERTERS.get(targetType);
Object result = converter.apply(stringValue);
```

#### 중앙 집중식 관리
- 모든 변환 로직이 한 곳에 모여있음
- 변환 규칙 수정 시 한 곳만 수정하면 됨

## 사용 패턴 예상 코드
```java
public static <T> T convert(String value, Class<T> targetType) {
    Function<String, Object> converter = CONVERTERS.get(targetType);
    if (converter == null) {
        throw new IllegalArgumentException("지원하지 않는 타입: " + targetType);
    }
    return (T) converter.apply(value);
}

// 사용 예시
Integer number = TypeConverter.convert("123", Integer.class);
LocalDate date = TypeConverter.convert("2024-01-01", LocalDate.class);
```

## 핵심 특징

1. **정적 초기화**: 클래스 로딩 시 한 번만 변환기들을 등록
2. **함수형 프로그래밍**: Function 인터페이스와 람다식 활용
3. **타입별 처리**: primitive와 wrapper 타입을 구분하여 처리
4. **null 안전성**: wrapper 타입에서 빈 문자열을 null로 처리
5. **확장 가능성**: 새로운 타입 추가가 용이한 구조