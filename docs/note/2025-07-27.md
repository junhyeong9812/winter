# 파일 업로드 핵심 클래스 상세 분석

## 📋 개요

Winter Framework 24챕터에서 구현하는 파일 업로드 기능의 핵심 클래스들을 한 줄씩 상세히 분석합니다.

---

## 1. HttpRequest.java - HTTP 요청 처리 클래스

### 구조 및 목적
Multipart 요청 지원을 위해 기존 HttpRequest를 확장한 클래스입니다.

```java
package winter.http;

import java.io.BufferedReader;        // 텍스트 스트림 읽기용
import java.io.StringReader;          // 문자열을 Reader로 변환
import java.util.*;                   // 컬렉션 프레임워크

/**
 * HTTP 요청 정보를 표현하는 클래스
 * 
 * 경로, 쿼리 파라미터, HTTP 메서드, 헤더, 요청 본문을 포함합니다.
 * Multipart 요청 처리를 위해 기존 구조를 확장했습니다.
 * 
 * 주요 변경사항:
 * 1. parameters를 Map<String, List<String>>으로 변경 (다중값 지원)
 * 2. 요청 본문 처리를 위한 BufferedReader 추가
 * 3. 새로운 생성자와 메서드 추가
 */
public class HttpRequest {
    // === 핵심 필드들 ===
    private final String path;                              // 요청 경로 ("/upload", "/api/users")
    private final String method;                            // HTTP 메서드 ("GET", "POST", "PUT" 등)
    private final Map<String, List<String>> parameters;    // 쿼리/폼 파라미터 (다중값 지원)
    private final Map<String, String> headers;             // HTTP 헤더들 (소문자 키로 정규화)
    private final BufferedReader body;                     // 요청 본문 스트림 (POST 데이터, Multipart 등)

    /**
     * 기본 생성자 (GET 요청 전용)
     * "/users?page=1&size=10" 같은 단순한 GET 요청에 사용
     */
    public HttpRequest(String rawPath) {
        this(rawPath, "GET");                               // 기본값으로 GET 메서드 설정
    }

    /**
     * 생성자 - 요청 경로 및 HTTP 메서드를 지정
     * 쿼리 파라미터는 자동으로 파싱됩니다.
     *
     * @param rawPath "/register?name=jun&tags=java&tags=spring" (쿼리 파라미터 포함 가능)
     * @param method "GET", "POST", "PUT", "DELETE" 등
     */
    public HttpRequest(String rawPath, String method) {
        this(rawPath, method, new HashMap<>(), new HashMap<>(), null);  // 완전한 생성자 호출
    }

    /**
     * 완전한 생성자 - 모든 요청 정보를 지정
     * Multipart 요청이나 복잡한 POST 요청에서 사용
     * 
     * @param rawPath 요청 경로 (쿼리 파라미터 포함 가능)
     * @param method HTTP 메서드
     * @param headers HTTP 헤더 맵 (Content-Type, Authorization 등)
     * @param parameters 파라미터 맵 (폼 데이터, Multipart 파라미터)
     * @param body 요청 본문 BufferedReader (POST/PUT 데이터)
     */
    public HttpRequest(String rawPath, String method, Map<String, String> headers, 
                      Map<String, List<String>> parameters, BufferedReader body) {
        // 메서드 정규화 (대문자로 변환, null 체크)
        this.method = method != null ? method.toUpperCase() : "GET";
        
        // 본문 스트림 초기화 (null이면 빈 스트림으로 초기화)
        this.body = body != null ? body : new BufferedReader(new StringReader(""));
        
        // 헤더 맵 초기화 및 복사 (키를 소문자로 정규화)
        this.headers = new HashMap<>();
        if (headers != null) {
            for (Map.Entry<String, String> entry : headers.entrySet()) {
                this.headers.put(entry.getKey().toLowerCase(), entry.getValue());  // 대소문자 무관하게 처리
            }
        }
        
        // 파라미터 맵 초기화 및 깊은 복사 (방어적 복사)
        this.parameters = new HashMap<>();
        if (parameters != null) {
            for (Map.Entry<String, List<String>> entry : parameters.entrySet()) {
                this.parameters.put(entry.getKey(), new ArrayList<>(entry.getValue()));  // 리스트도 복사
            }
        }
        
        // 경로에서 쿼리 파라미터 파싱
        String[] parts = rawPath.split("\\?", 2);           // "?"로 경로와 쿼리 분리 (최대 2개로 분할)
        this.path = parts[0];                               // 순수 경로 부분

        if (parts.length > 1) {                             // 쿼리 파라미터가 있으면
            parseQueryString(parts[1]);                     // 쿼리 문자열 파싱
        }
    }

    /**
     * 쿼리 문자열을 파싱하여 파라미터 맵에 추가
     * "name=john&age=25&tags=java&tags=spring" 형태의 문자열 처리
     */
    private void parseQueryString(String queryString) {
        if (queryString == null || queryString.trim().isEmpty()) {
            return;                                         // 빈 쿼리 문자열은 무시
        }
        
        String[] pairs = queryString.split("&");           // "&"로 각 파라미터 분리
        for (String pair : pairs) {
            String[] kv = pair.split("=", 2);              // "="로 키-값 분리 (최대 2개)
            if (kv.length >= 1) {                           // 키가 있으면 (값이 없어도 됨)
                String key = urlDecode(kv[0]);              // URL 디코딩 적용
                String value = kv.length == 2 ? urlDecode(kv[1]) : "";  // 값이 없으면 빈 문자열
                addParameter(key, value);                   // 파라미터 맵에 추가
            }
        }
    }
    
    /**
     * 간단한 URL 디코딩 (+ → 공백, %20 → 공백 등)
     * 실제로는 더 복잡한 디코딩이 필요하지만 여기서는 기본만 처리
     */
    private String urlDecode(String value) {
        if (value == null) return "";
        return value.replace("+", " ")                      // "+" 문자를 공백으로
                   .replace("%20", " ");                    // "%20"을 공백으로
    }

    // === Getter 메서드들 ===
    
    /**
     * 순수 요청 경로 반환 (쿼리 파라미터 제외)
     * 예: "/register?name=jun" → "/register"
     */
    public String getPath() {
        return path;
    }

    /**
     * HTTP 메서드 반환 (대문자로 정규화됨)
     * 예: "get" → "GET", "post" → "POST"
     */
    public String getMethod() {
        return method;
    }

    /**
     * 요청 본문 BufferedReader 반환
     * POST/PUT 요청의 데이터나 Multipart 데이터 읽기용
     */
    public BufferedReader getBody() {
        return body;
    }

    // === 파라미터 관련 메서드들 ===

    /**
     * 개별 파라미터의 첫 번째 값 조회
     * 가장 자주 사용되는 메서드 (단일값 파라미터용)
     * 
     * @param key 파라미터 이름 ("name", "email" 등)
     * @return 첫 번째 값, 없으면 null
     */
    public String getParameter(String key) {
        List<String> values = parameters.get(key);         // 해당 키의 값 리스트 조회
        return (values != null && !values.isEmpty()) ? values.get(0) : null;  // 첫 번째 값 반환
    }

    /**
     * 개별 파라미터의 모든 값 조회
     * 다중 선택 체크박스나 multiple 파일 업로드에서 사용
     * 
     * @param key 파라미터 이름
     * @return 값 목록 (방어적 복사본), 없으면 빈 리스트
     */
    public List<String> getParameterValues(String key) {
        return new ArrayList<>(parameters.getOrDefault(key, Collections.emptyList()));  // 방어적 복사
    }

    /**
     * 전체 파라미터 Map 반환 (하위 호환성을 위해 첫 번째 값만)
     * 
     * @deprecated getParameterMap() 사용 권장
     * @return 파라미터명 -> 첫 번째 값 맵
     */
    @Deprecated                                             // 더 이상 권장하지 않음을 표시
    public Map<String, String> getParameters() {
        Map<String, String> result = new HashMap<>();
        for (Map.Entry<String, List<String>> entry : parameters.entrySet()) {
            List<String> values = entry.getValue();
            if (!values.isEmpty()) {
                result.put(entry.getKey(), values.get(0)); // 첫 번째 값만 사용 (하위 호환성)
            }
        }
        return result;
    }
    
    /**
     * 전체 파라미터 Map 반환 (다중값 지원)
     * 새로운 코드에서는 이 메서드를 사용하세요.
     */
    public Map<String, List<String>> getParameterMap() {
        Map<String, List<String>> result = new HashMap<>();
        for (Map.Entry<String, List<String>> entry : parameters.entrySet()) {
            result.put(entry.getKey(), new ArrayList<>(entry.getValue()));  // 방어적 복사
        }
        return result;
    }

    /**
     * 파라미터 추가 (기존 값에 추가)
     * 같은 키에 여러 값을 추가할 때 사용
     */
    public void addParameter(String key, String value) {
        parameters.computeIfAbsent(key, k -> new ArrayList<>()).add(value);  // 키가 없으면 리스트 생성 후 추가
    }
    
    /**
     * 파라미터 설정 (기존 값 덮어쓰기)
     * 단일값으로 파라미터를 설정할 때 사용
     */
    public void setParameter(String key, String value) {
        List<String> values = new ArrayList<>();
        values.add(value);
        parameters.put(key, values);                        // 기존 값들을 모두 교체
    }
    
    /**
     * 파라미터 설정 (다중값)
     * 여러 값을 한 번에 설정할 때 사용
     */
    public void setParameterValues(String key, List<String> values) {
        parameters.put(key, new ArrayList<>(values));       // 방어적 복사로 저장
    }

    /**
     * 파라미터 존재 여부 확인
     * 값이 있는지 검사 (빈 리스트는 존재하지 않는 것으로 간주)
     */
    public boolean hasParameter(String key) {
        return parameters.containsKey(key) && !parameters.get(key).isEmpty();
    }
    
    /**
     * 모든 파라미터 이름 반환
     * 어떤 파라미터들이 있는지 확인할 때 사용
     */
    public Set<String> getParameterNames() {
        return new HashSet<>(parameters.keySet());          // 방어적 복사
    }

    // === 헤더 관련 메서드들 ===

    /**
     * 헤더 추가/설정
     * 키는 자동으로 소문자로 정규화됩니다 (HTTP 헤더는 대소문자 무관)
     */
    public void addHeader(String key, String value) {
        headers.put(key.toLowerCase(), value);              // 소문자로 정규화하여 저장
    }

    /**
     * 헤더 조회
     * 대소문자 무관하게 조회 가능
     */
    public String getHeader(String key) {
        return headers.get(key.toLowerCase());              // 소문자로 정규화하여 조회
    }

    /**
     * 전체 헤더 Map 반환 (방어적 복사)
     */
    public Map<String, String> getHeaders() {
        return new HashMap<>(headers);                      // 방어적 복사로 외부 수정 방지
    }
    
    /**
     * 헤더 존재 여부 확인
     */
    public boolean hasHeader(String key) {
        return headers.containsKey(key.toLowerCase());      // 소문자로 정규화하여 확인
    }

    // === 편의 메서드들 ===

    /**
     * Content-Type 헤더 편의 메서드
     * 파일 업로드에서 "multipart/form-data" 확인 등에 자주 사용
     */
    public String getContentType() {
        return getHeader("Content-Type");
    }
    
    /**
     * Content-Length 헤더 편의 메서드
     * 요청 본문의 크기 확인
     */
    public long getContentLength() {
        String contentLength = getHeader("Content-Length");
        if (contentLength != null) {
            try {
                return Long.parseLong(contentLength);       // 문자열을 숫자로 변환
            } catch (NumberFormatException e) {
                return -1;                                  // 파싱 실패 시 -1 반환
            }
        }
        return -1;                                          // 헤더가 없으면 -1 반환
    }

    /**
     * 요청이 특정 Content-Type인지 확인
     * "multipart/form-data; boundary=..." 같은 경우도 처리
     */
    public boolean isContentType(String contentType) {
        String actualContentType = getContentType();
        return actualContentType != null && 
               actualContentType.toLowerCase().startsWith(contentType.toLowerCase());  // 대소문자 무관 비교
    }
    
    /**
     * POST 요청인지 확인
     */
    public boolean isPost() {
        return "POST".equals(method);
    }
    
    /**
     * GET 요청인지 확인
     */
    public boolean isGet() {
        return "GET".equals(method);
    }

    /**
     * 디버깅을 위한 문자열 표현
     * 민감한 정보는 제외하고 요약 정보만 표시
     */
    @Override
    public String toString() {
        return "HttpRequest{" +
                "method='" + method + '\'' +
                ", path='" + path + '\'' +
                ", parameters=" + parameters.size() + " entries" +  // 파라미터 개수만 표시
                ", headers=" + headers.size() + " entries" +        // 헤더 개수만 표시
                ", contentType='" + getContentType() + '\'' +
                '}';
    }
}
```

---

## 2. MultipartFile.java - 파일 업로드 인터페이스

### 구조 및 목적
업로드된 파일을 추상화하는 인터페이스로, Spring의 MultipartFile을 참고하여 설계되었습니다.

```java
package winter.upload;

import java.io.File;                   // 파일 시스템의 파일 표현
import java.io.IOException;            // 입출력 예외
import java.io.InputStream;            // 바이트 입력 스트림

/**
 * 업로드된 파일을 추상화하는 인터페이스
 * HTTP multipart/form-data 요청에서 업로드된 파일을 나타냅니다.
 * 
 * 이 인터페이스는 Spring의 MultipartFile을 참고하여 설계되었으며,
 * 파일의 메타데이터와 내용에 접근할 수 있는 메서드들을 제공합니다.
 * 
 * 설계 원칙:
 * - 파일 크기에 관계없이 일관된 인터페이스 제공
 * - 메모리 효율적인 처리 지원 (스트림 기반)
 * - 안전한 파일 저장 메커니즘
 */
public interface MultipartFile {
    
    /**
     * HTML 폼에서 사용된 필드명을 반환합니다.
     * 
     * HTML 예시: <input type="file" name="avatar"> → "avatar"
     * 하나의 요청에서 여러 파일 필드가 있을 수 있으므로 구분자 역할
     * 
     * @return 폼 필드명 (never null, 빈 문자열 가능)
     */
    String getName();
    
    /**
     * 클라이언트가 업로드한 원본 파일명을 반환합니다.
     * 
     * 예시: "profile.jpg", "document.pdf", "resume.docx"
     * 
     * 주의사항:
     * - 보안상 경로 정보가 포함될 수 있음 (C:\Users\john\photo.jpg)
     * - 파일명에 위험한 문자가 포함될 수 있음 (../../../etc/passwd)
     * - 서버에 저장할 때는 반드시 sanitize 필요
     * 
     * @return 원본 파일명, 파일이 선택되지 않았다면 빈 문자열
     */
    String getOriginalFilename();
    
    /**
     * 파일의 Content-Type을 반환합니다.
     * 
     * 예시: "image/jpeg", "application/pdf", "text/plain"
     * 
     * 용도:
     * - 파일 유형 검증 (이미지만 허용, 문서만 허용 등)
     * - 적절한 처리기 선택
     * - HTTP 응답 시 Content-Type 설정
     * 
     * 주의사항:
     * - 클라이언트가 제공하는 정보이므로 신뢰할 수 없음
     * - 실제 파일 내용과 다를 수 있음 (보안 검증 필요)
     * 
     * @return Content-Type, 알 수 없다면 null
     */
    String getContentType();
    
    /**
     * 업로드된 파일이 비어있는지 확인합니다.
     * 
     * 비어있는 경우:
     * - 파일이 선택되지 않음 (<input type="file">에서 선택 안함)
     * - 크기가 0인 파일
     * - null 파일
     * 
     * 용도:
     * - 필수 파일 업로드 검증
     * - 불필요한 처리 방지
     * 
     * @return 파일이 비어있거나 업로드되지 않았다면 true
     */
    boolean isEmpty();
    
    /**
     * 파일의 크기를 바이트 단위로 반환합니다.
     * 
     * 용도:
     * - 파일 크기 제한 검증 (예: 10MB 이하만 허용)
     * - 디스크 공간 확인
     * - 진행률 표시
     * - 로깅 및 통계
     * 
     * @return 파일 크기 (바이트), 음수면 알 수 없음
     */
    long getSize();
    
    /**
     * 파일의 전체 내용을 byte 배열로 반환합니다.
     * 
     * 주의사항:
     * - 대용량 파일의 경우 메모리 부족 위험!
     * - 파일 전체를 메모리에 로드함
     * - 가능하면 getInputStream() 사용 권장
     * 
     * 적절한 사용 경우:
     * - 작은 파일 (1MB 미만)
     * - 파일 내용 전체를 한 번에 처리해야 하는 경우
     * - 암호화/해시 계산 등
     * 
     * @return 파일 내용 (복사본)
     * @throws IOException 파일 읽기 실패시
     */
    byte[] getBytes() throws IOException;
    
    /**
     * 파일 내용을 읽을 수 있는 InputStream을 반환합니다.
     * 
     * 장점:
     * - 메모리 효율적 (청크 단위로 읽기)
     * - 대용량 파일 처리 가능
     * - 스트림 체이닝 가능 (BufferedInputStream 등과 조합)
     * 
     * 사용 패턴:
     * try (InputStream is = file.getInputStream()) {
     *     // 파일 처리
     * } // 자동으로 close() 호출
     * 
     * 주의사항:
     * - 사용 후 반드시 close() 호출 필요
     * - try-with-resources 구문 사용 권장
     * 
     * @return 파일 내용 스트림
     * @throws IOException 스트림 생성 실패시
     */
    InputStream getInputStream() throws IOException;
    
    /**
     * 업로드된 파일을 지정된 위치에 저장합니다.
     * 
     * 특징:
     * - 메모리 효율적인 저장 (스트림 기반)
     * - 대용량 파일도 안전하게 처리
     * - 원자적 연산 (성공 또는 실패, 중간 상태 없음)
     * 
     * 내부 처리:
     * 1. 대상 디렉토리 존재 확인 및 생성
     * 2. 임시 파일로 저장 후 원본으로 이동 (원자적 처리)
     * 3. 파일 권한 설정
     * 4. 메타데이터 보존
     * 
     * 예외 상황:
     * - 디스크 공간 부족
     * - 권한 부족
     * - 대상 파일이 이미 존재하고 쓰기 불가
     * 
     * @param dest 저장할 파일 위치 (디렉토리 + 파일명)
     * @throws IOException 파일 저장 실패시
     * @throws IllegalStateException 파일이 이미 처리되었거나 이동할 수 없는 상태일 때
     */
    void transferTo(File dest) throws IOException;
}
```

---

## 3. StandardMultipartFile.java - MultipartFile 구현체

### 구조 및 목적
MultipartFile 인터페이스의 표준 구현체로, 파일 데이터를 메모리에 저장하여 관리합니다.

```java
package winter.upload;

import java.io.*;                      // 입출력 관련 클래스들
import java.nio.file.Files;            // NIO 파일 작업 유틸리티
import java.nio.file.StandardCopyOption; // 파일 복사 옵션

/**
 * MultipartFile의 표준 구현체
 * 
 * 설계 특징:
 * - 파일 내용을 byte 배열로 메모리에 저장
 * - 불변 객체 (immutable) - 생성 후 내용 변경 불가
 * - 방어적 복사를 통한 데이터 보호
 * - 작은 파일에 최적화됨
 * 
 * 적합한 사용 사례:
 * - 일반적인 웹 파일 업로드 (10MB 이하)
 * - 파일 내용에 여러 번 접근해야 하는 경우
 * - 파일 검증 및 처리가 필요한 경우
 * 
 * 부적합한 사용 사례:
 * - 대용량 파일 (100MB 이상) - 메모리 부족 위험
 * - 파일 내용을 한 번만 읽는 경우 - 불필요한 메모리 사용
 * - 스트리밍 처리가 필요한 경우
 */
public class StandardMultipartFile implements MultipartFile {
    
    // === 불변 필드들 (final로 선언) ===
    private final String name;                              // HTML 폼 필드명 (예: "avatar", "document")
    private final String originalFilename;                 // 클라이언트의 원본 파일명 (예: "photo.jpg")
    private final String contentType;                      // MIME 타입 (예: "image/jpeg", "application/pdf")
    private final byte[] content;                          // 파일 내용 (불변 배열)
    
    /**
     * StandardMultipartFile 생성자
     * 
     * 모든 파라미터는 방어적으로 처리되어 null-safe를 보장합니다.
     * 
     * @param name 폼 필드명 (null이면 빈 문자열로 처리)
     * @param originalFilename 원본 파일명 (null이면 빈 문자열로 처리)
     * @param contentType MIME 타입 (null 허용)
     * @param content 파일 내용 (null이면 빈 배열로 처리)
     */
    public StandardMultipartFile(String name, String originalFilename, 
                               String contentType, byte[] content) {
        // null-safe 처리: null이 들어와도 안전하게 처리
        this.name = name != null ? name : "";               // null이면 빈 문자열
        this.originalFilename = originalFilename != null ? originalFilename : "";  // null이면 빈 문자열
        this.contentType = contentType;                     // null 허용 (MIME 타입이 없을 수 있음)
        this.content = content != null ? content : new byte[0];  // null이면 빈 배열 (길이 0)
    }
    
    // === MultipartFile 인터페이스 구현 ===
    
    /**
     * 폼 필드명 반환
     * @return HTML form의 input name 속성값
     */
    @Override
    public String getName() {
        return name;
    }
    
    /**
     * 원본 파일명 반환
     * @return 클라이언트가 업로드한 파일의 원래 이름
     */
    @Override
    public String getOriginalFilename() {
        return originalFilename;
    }
    
    /**
     * Content-Type 반환
     * @return MIME 타입 문자열 또는 null
     */
    @Override
    public String getContentType() {
        return contentType;
    }
    
    /**
     * 파일이 비어있는지 확인
     * @return 파일 내용이 없으면 true
     */
    @Override
    public boolean isEmpty() {
        return content.length == 0;                         // 배열 길이가 0이면 빈 파일
    }
    
    /**
     * 파일 크기 반환
     * @return 바이트 단위 파일 크기
     */
    @Override
    public long getSize() {
        return content.length;                              // 배열 길이 = 파일 크기
    }
    
    /**
     * 파일 내용을 byte 배열로 반환
     * 
     * 방어적 복사(defensive copy)를 수행하여 원본 데이터를 보호합니다.
     * 반환된 배열을 수정해도 원본에는 영향이 없습니다.
     * 
     * @return 파일 내용의 복사본
     * @throws IOException 실제로는 발생하지 않음 (메모리 기반이므로)
     */
    @Override
    public byte[] getBytes() throws IOException {
        return content.clone();                             // 배열 복사본 반환 (원본 보호)
    }
    
    /**
     * 파일 내용을 읽을 수 있는 InputStream 반환
     * 
     * ByteArrayInputStream을 사용하여 메모리의 byte 배열을
     * InputStream으로 래핑합니다.
     * 
     * 특징:
     * - 메모리 기반이므로 빠름
     * - mark/reset 지원
     * - thread-safe하지 않음 (동시 접근 주의)
     * 
     * @return 파일 내용을 읽을 수 있는 InputStream
     * @throws IOException 실제로는 발생하지 않음
     */
    @Override
    public InputStream getInputStream() throws IOException {
        return new ByteArrayInputStream(content);           // 메모리 기반 InputStream 생성
    }
    
    /**
     * 파일을 지정된 위치에 저장
     * 
     * 처리 순서:
     * 1. 대상 파일 null 체크
     * 2. 부모 디렉토리 존재 확인 및 생성
     * 3. NIO Files.copy()를 사용한 안전한 파일 복사
     * 
     * @param dest 저장할 파일 위치
     * @throws IOException 파일 저장 실패시
     */
    @Override
    public void transferTo(File dest) throws IOException {
        // 1. 입력 검증
        if (dest == null) {
            throw new IllegalArgumentException("Destination file cannot be null");
        }
        
        // 2. 목적지 디렉토리가 존재하지 않으면 생성
        File parentDir = dest.getParentFile();              // 부모 디렉토리 가져오기
        if (parentDir != null && !parentDir.exists()) {     // 부모 디렉토리가 없으면
            if (!parentDir.mkdirs()) {                       // 디렉토리 생성 시도
                throw new IOException("Could not create directory: " + parentDir.getAbsolutePath());
            }
        }
        
        // 3. 파일 저장 (NIO 사용)
        try (InputStream is = getInputStream()) {            // try-with-resources로 자동 close
            Files.copy(is, dest.toPath(), StandardCopyOption.REPLACE_EXISTING);  // 파일 복사
            // REPLACE_EXISTING: 대상 파일이 이미 존재하면 덮어쓰기
        }
    }
    
    // === Object 클래스 메서드 오버라이드 ===
    
    /**
     * 디버깅을 위한 문자열 표현
     * 파일 내용은 표시하지 않고 메타데이터만 표시
     */
    @Override
    public String toString() {
        return "StandardMultipartFile{" +
                "name='" + name + '\'' +                    // 필드명
                ", originalFilename='" + originalFilename + '\'' +  // 원본 파일명
                ", contentType='" + contentType + '\'' +    // MIME 타입
                ", size=" + getSize() +                     // 파일 크기
                ", isEmpty=" + isEmpty() +                  // 빈 파일 여부
                '}';
    }
    
    /**
     * 객체 동등성 비교
     * 
     * 동등성 기준:
     * 1. 같은 참조면 true (성능 최적화)
     * 2. null이거나 다른 클래스면 false
     * 3. 모든 필드가 같으면 true
     * 
     * Arrays.equals() 사용 이유:
     * - 배열은 == 연산자로 비교하면 참조만 비교됨
     * - Arrays.equals()는 배열의 내용을 비교함
     * - null 배열도 안전하게 처리
     */
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;                       // 1. 참조 동등성 (빠른 경로)
        if (obj == null || getClass() != obj.getClass()) return false;  // 2. null 및 타입 체크
        
        StandardMultipartFile that = (StandardMultipartFile) obj;  // 3. 형변환
        return name.equals(that.name) &&                   // 4. 필드별 비교
               originalFilename.equals(that.originalFilename) &&
               (contentType != null ? contentType.equals(that.contentType) : that.contentType == null) &&
               java.util.Arrays.equals(content, that.content);  // 배열 내용 비교
    }
    
    /**
     * 해시코드 계산
     * 
     * equals()가 true인 객체들은 같은 해시코드를 가져야 함 (해시코드 계약)
     * 
     * 계산 방식:
     * 1. name.hashCode()로 시작
     * 2. 31을 곱하고 다음 필드의 해시코드 추가
     * 3. null 필드는 0으로 처리
     * 4. 배열은 Arrays.hashCode() 사용
     * 
     * 31을 사용하는 이유:
     * - 홀수 소수로 해시 분산성이 좋음
     * - 31 * i == (i << 5) - i로 최적화 가능
     * - String 클래스에서도 동일하게 사용
     */
    @Override
    public int hashCode() {
        int result = name.hashCode();                       // 첫 번째 필드의 해시코드
        result = 31 * result + originalFilename.hashCode(); // 31 곱하고 다음 필드 추가
        result = 31 * result + (contentType != null ? contentType.hashCode() : 0);  // null 안전 처리
        result = 31 * result + java.util.Arrays.hashCode(content);  // 배열 해시코드
        return result;
    }
}
```

---

## 4. MultipartRequest.java - Multipart 요청 확장 클래스

### 구조 및 목적
HttpRequest를 확장하여 파일 업로드가 포함된 multipart/form-data 요청을 처리합니다.

```java
package winter.upload;

import winter.http.HttpRequest;         // 기본 HTTP 요청 클래스
import java.io.BufferedReader;          // 텍스트 스트림 읽기
import java.util.*;                     // 컬렉션 프레임워크

/**
 * Multipart 요청을 처리하는 HttpRequest 확장 클래스
 * 
 * multipart/form-data 형태의 요청에서 파일과 일반 파라미터를 분리하여 관리합니다.
 * 
 * 설계 원칙:
 * - HttpRequest의 모든 기능을 상속
 * - 파일 관련 기능을 추가로 제공
 * - 일반 파라미터와 파일을 명확히 구분
 * - 다중 파일 업로드 지원
 * 
 * 사용 시나리오:
 * - 파일 업로드가 포함된 폼 제출
 * - 프로필 정보 + 아바타 이미지 업로드
 * - 문서 + 첨부파일 업로드
 * - Ajax 파일 업로드
 */
public class MultipartRequest extends HttpRequest {
    
    // === 파일 관리 필드 ===
    private final Map<String, List<MultipartFile>> files;  // 필드명 -> 파일 리스트 맵
    
    /**
     * MultipartRequest 생성자
     * 
     * 부모 클래스(HttpRequest)의 생성자를 호출하고
     * 파일 맵을 추가로 초기화합니다.
     * 
     * @param method HTTP 메서드 ("POST", "PUT" 등)
     * @param path 요청 경로 ("/upload", "/api/files" 등)
     * @param headers HTTP 헤더 맵 (Content-Type 등)
     * @param parameters 일반 파라미터 맵 (텍스트 필드들)
     * @param body 요청 본문 BufferedReader (multipart 데이터)
     * @param files 업로드된 파일 맵 (파일 필드들)
     */
    public MultipartRequest(String method, String path, Map<String, String> headers, 
                          Map<String, List<String>> parameters, BufferedReader body, 
                          Map<String, List<MultipartFile>> files) {
        // 부모 클래스 생성자 호출 (HttpRequest 초기화)
        super(method, path, headers, parameters, body);
        
        // 파일 맵 초기화 (null-safe 처리)
        this.files = files != null ? files : new HashMap<>();
    }
    
    // === 단일 파일 접근 메서드들 ===
    
    /**
     * 지정된 이름의 첫 번째 파일을 반환합니다.
     * 
     * 사용 사례:
     * - 단일 파일 업로드 (<input type="file" name="avatar">)
     * - 다중 파일 중 첫 번째만 필요한 경우
     * 
     * @param name 파일 필드명 (HTML의 input name)
     * @return 업로드된 파일, 없으면 null
     */
    public MultipartFile getFile(String name) {
        List<MultipartFile> fileList = files.get(name);    // 해당 필드의 파일 리스트 조회
        return (fileList != null && !fileList.isEmpty()) ? fileList.get(0) : null;  // 첫 번째 파일 반환
    }
    
    // === 다중 파일 접근 메서드들 ===
    
    /**
     * 지정된 이름의 모든 파일을 반환합니다.
     * 
     * 사용 사례:
     * - 다중 파일 업로드 (<input type="file" name="documents" multiple>)
     * - 같은 이름의 파일 필드가 여러 개인 경우
     * - 파일 배열 처리
     * 
     * @param name 파일 필드명
     * @return 업로드된 파일 목록 (방어적 복사본)
     */
    public List<MultipartFile> getFiles(String name) {
        return new ArrayList<>(files.getOrDefault(name, Collections.emptyList()));  // 방어적 복사
    }
    
    /**
     * 모든 파일의 맵을 반환합니다.
     * 
     * 사용 사례:
     * - 전체 파일 목록 조회
     * - 파일 통계 계산
     * - 로깅 및 디버깅
     * 
     * @return 파일명 -> 파일 목록 맵 (방어적 복사본)
     */
    public Map<String, List<MultipartFile>> getFileMap() {
        Map<String, List<MultipartFile>> result = new HashMap<>();
        for (Map.Entry<String, List<MultipartFile>> entry : files.entrySet()) {
            result.put(entry.getKey(), new ArrayList<>(entry.getValue()));  // 깊은 복사
        }
        return result;
    }
    
    // === 파일 존재 여부 확인 메서드들 ===
    
    /**
     * 업로드된 파일이 있는지 확인합니다.
     * 
     * 확인 조건:
     * 1. files 맵이 비어있지 않음
     * 2. 실제로 파일이 포함된 리스트가 존재함
     * 
     * @return 파일이 하나라도 있으면 true
     */
    public boolean hasFiles() {
        return !files.isEmpty() && files.values().stream()  // 모든 파일 리스트에 대해
                .anyMatch(fileList -> !fileList.isEmpty()); // 하나라도 비어있지 않은지 확인
    }
    
    /**
     * 특정 이름의 파일이 있는지 확인합니다.
     * 
     * 확인 조건:
     * 1. 해당 필드명이 존재함
     * 2. 해당 필드에 실제 파일이 있음 (빈 리스트가 아님)
     * 
     * @param name 파일 필드명
     * @return 해당 이름의 파일이 있으면 true
     */
    public boolean hasFile(String name) {
        List<MultipartFile> fileList = files.get(name);
        return fileList != null && !fileList.isEmpty();    // null이 아니고 비어있지 않음
    }
    
    // === 파일 메타데이터 조회 메서드들 ===
    
    /**
     * 업로드된 모든 파일 필드명을 반환합니다.
     * 
     * 사용 사례:
     * - 어떤 파일 필드들이 업로드되었는지 확인
     * - 동적 파일 처리 (필드명에 따라 다른 처리)
     * - 로깅 및 디버깅
     * 
     * @return 파일 필드명 집합 (방어적 복사본)
     */
    public Set<String> getFileNames() {
        return new HashSet<>(files.keySet());              // 방어적 복사
    }
    
    /**
     * 총 업로드된 파일 개수를 반환합니다.
     * 
     * 계산 방식:
     * - 모든 파일 리스트의 크기를 합산
     * - Stream API를 사용한 함수형 프로그래밍
     * 
     * @return 전체 파일 개수
     */
    public int getFileCount() {
        return files.values().stream()                     // 모든 파일 리스트에 대해
                .mapToInt(List::size)                       // 각 리스트의 크기를 int로 변환
                .sum();                                     // 모든 크기를 합산
    }
    
    /**
     * 특정 필드의 파일 개수를 반환합니다.
     * 
     * @param name 파일 필드명
     * @return 해당 필드의 파일 개수
     */
    public int getFileCount(String name) {
        List<MultipartFile> fileList = files.get(name);
        return fileList != null ? fileList.size() : 0;     // null이면 0, 아니면 리스트 크기
    }
    
    /**
     * 업로드된 모든 파일의 총 크기를 반환합니다.
     * 
     * 계산 방식:
     * 1. 모든 파일 리스트를 하나의 스트림으로 합침 (flatMap)
     * 2. 각 파일의 크기를 long으로 변환 (mapToLong)
     * 3. 모든 크기를 합산 (sum)
     * 
     * 사용 사례:
     * - 디스크 공간 확인
     * - 업로드 제한 검증
     * - 통계 및 로깅
     * 
     * @return 총 파일 크기 (바이트)
     */
    public long getTotalFileSize() {
        return files.values().stream()                     // 모든 파일 리스트
                .flatMap(List::stream)                      // 하나의 파일 스트림으로 합침
                .mapToLong(MultipartFile::getSize)          // 각 파일의 크기
                .sum();                                     // 총합
    }
    
    // === Object 클래스 메서드 오버라이드 ===
    
    /**
     * 디버깅을 위한 문자열 표현
     * 
     * 표시 정보:
     * - HTTP 메서드와 경로 (부모 클래스에서 상속)
     * - 파일 개수 및 총 크기
     * - 파일 필드명 목록
     * 
     * 개인정보 보호:
     * - 파일 내용은 표시하지 않음
     * - 파일명도 보안상 표시하지 않음
     * - 통계 정보만 표시
     */
    @Override
    public String toString() {
        return "MultipartRequest{" +
                "method='" + getMethod() + '\'' +           // HTTP 메서드
                ", path='" + getPath() + '\'' +             // 요청 경로
                ", fileCount=" + getFileCount() +           // 총 파일 개수
                ", totalFileSize=" + getTotalFileSize() + " bytes" +  // 총 파일 크기
                ", fileNames=" + getFileNames() +           // 파일 필드명들
                '}';
    }
}
```

이제 모든 핵심 클래스의 상세 분석이 완성되었습니다!

## 📚 종합 요약

### 설계 패턴 및 원칙
1. **인터페이스 분리**: MultipartFile 인터페이스로 추상화
2. **방어적 프로그래밍**: null 체크, 방어적 복사
3. **불변성**: final 필드, 방어적 복사로 데이터 보호
4. **확장성**: HttpRequest 상속으로 기능 확장
5. **메모리 효율성**: 스트림 기반 처리 지원

### 핵심 기술 요소
1. **Java I/O/NIO**: 효율적인 파일 처리
2. **equals/hashCode**: 해시 기반 컬렉션 지원
3. **Stream API**: 함수형 프로그래밍으로 가독성 향상
4. **방어적 복사**: 데이터 무결성 보장
5. **@Deprecated**: 하위 호환성과 API 진화

이 구현을 통해 Spring MVC와 유사한 수준의 파일 업로드 기능을 제공할 수 있습니다! 🎯