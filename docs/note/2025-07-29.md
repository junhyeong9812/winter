# Winter Framework - Multipart Parser 완전 분석

## 📋 목차

1. [Multipart/Form-Data 기본 개념](#1-multipartform-data-기본-개념)
2. [HTTP Multipart 구조 분석](#2-http-multipart-구조-분석)
3. [Boundary의 역할과 의미](#3-boundary의-역할과-의미)
4. [CRLF(Carriage Return Line Feed)의 중요성](#4-crlfcarriage-return-line-feed의-중요성)
5. [MultipartParser 코드 상세 분석](#5-multipartparser-코드-상세-분석)
6. [파일 업로드 시스템 아키텍처](#6-파일-업로드-시스템-아키텍처)
7. [핵심 질문들에 대한 답변](#7-핵심-질문들에-대한-답변)

---

## 1. Multipart/Form-Data 기본 개념

### 1.1 왜 Multipart가 필요한가?

일반적인 HTTP POST 요청은 `application/x-www-form-urlencoded` 형태로 데이터를 전송합니다:
```
name=John&age=25&email=john@example.com
```

하지만 **파일을 업로드**할 때는 다음과 같은 문제가 발생합니다:
- **바이너리 데이터**: 이미지, 동영상 등은 텍스트가 아닌 바이너리 데이터
- **메타데이터 필요**: 파일명, MIME 타입 등의 추가 정보 필요
- **혼합 데이터**: 파일과 일반 텍스트 필드를 함께 전송해야 함

### 1.2 Multipart의 해결책

`multipart/form-data`는 이러한 문제를 해결하기 위해 **여러 부분(parts)으로 나누어** 데이터를 전송합니다:

```http
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW

------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="username"

john_doe
------WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Disposition: form-data; name="avatar"; filename="profile.jpg"
Content-Type: image/jpeg

[바이너리 이미지 데이터...]
------WebKitFormBoundary7MA4YWxkTrZu0gW--
```

---

## 2. HTTP Multipart 구조 분석

### 2.1 Multipart 메시지의 구성 요소

```
1. HTTP 헤더
   ├── Content-Type: multipart/form-data; boundary=XXX
   └── Content-Length: [전체 크기]

2. 메시지 본문
   ├── 시작 boundary (--XXX)
   ├── Part 1
   │   ├── Part 헤더 (Content-Disposition, Content-Type 등)
   │   ├── 빈 줄 (CRLF)
   │   └── Part 데이터
   ├── 구분 boundary (--XXX)
   ├── Part 2
   │   ├── Part 헤더
   │   ├── 빈 줄 (CRLF)
   │   └── Part 데이터
   ├── 구분 boundary (--XXX)
   └── 종료 boundary (--XXX--)
```

### 2.2 실제 예시

```http
POST /upload HTTP/1.1
Host: localhost:8080
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW
Content-Length: 12345

------WebKitFormBoundary7MA4YWxkTrZu0gW\r\n
Content-Disposition: form-data; name="description"\r\n
\r\n
사용자 프로필 사진입니다\r\n
------WebKitFormBoundary7MA4YWxkTrZu0gW\r\n
Content-Disposition: form-data; name="file"; filename="profile.jpg"\r\n
Content-Type: image/jpeg\r\n
\r\n
[JPEG 바이너리 데이터...]\r\n
------WebKitFormBoundary7MA4YWxkTrZu0gW--\r\n
```

---

## 3. Boundary의 역할과 의미

### 3.1 Boundary란?

**Boundary**는 multipart 메시지에서 **각 part를 구분하는 구분자**입니다.

#### 특징:
- **고유성**: 메시지 내용에 나타나지 않는 고유한 문자열
- **RFC 규칙**: 최대 70자, 영숫자와 일부 특수문자만 사용
- **자동 생성**: 브라우저나 클라이언트가 자동으로 생성

### 3.2 Boundary의 형태

```
기본 형태: ----WebKitFormBoundary7MA4YWxkTrZu0gW
구분 형태: ------WebKitFormBoundary7MA4YWxkTrZu0gW     (앞에 --)
종료 형태: ------WebKitFormBoundary7MA4YWxkTrZu0gW--   (뒤에도 --)
```

### 3.3 파싱에서 Boundary 처리

```java
// 1. Content-Type에서 boundary 추출
String boundary = extractBoundary(contentType);
// "----WebKitFormBoundary7MA4YWxkTrZu0gW"

// 2. 파싱용 구분자 생성
String delimiter = "--" + boundary;
// "------WebKitFormBoundary7MA4YWxkTrZu0gW"

String endDelimiter = delimiter + "--";
// "------WebKitFormBoundary7MA4YWxkTrZu0gW--"
```

---

## 4. CRLF(Carriage Return Line Feed)의 중요성

### 4.1 CRLF란?

- **CR (Carriage Return)**: `\r` (ASCII 13)
- **LF (Line Feed)**: `\n` (ASCII 10)
- **CRLF**: `\r\n` - HTTP 표준에서 사용하는 줄바꿈

### 4.2 운영체제별 줄바꿈 차이

```
Windows: \r\n (CRLF)
Unix/Linux: \n (LF)
Mac (구버전): \r (CR)
HTTP 표준: \r\n (CRLF) ← 반드시 이것을 사용!
```

### 4.3 CRLF가 중요한 이유

#### 1. **헤더와 본문 구분**
```
Content-Disposition: form-data; name="file"\r\n
Content-Type: image/jpeg\r\n
\r\n    ← 이 빈 줄(CRLF)이 헤더와 본문을 구분!
[파일 데이터 시작...]
```

#### 2. **Part 경계 구분**
```
------boundary\r\n    ← boundary 뒤의 CRLF
[part 내용]
------boundary\r\n    ← 다음 boundary 앞의 CRLF
```

#### 3. **파싱 정확성**
CRLF를 제대로 처리하지 않으면:
- 헤더에 불필요한 문자가 포함됨
- Part 데이터가 잘못 추출됨
- 바이너리 파일이 손상됨

### 4.4 코드에서 CRLF 처리

```java
// 요청 본문 읽을 때 CRLF 보존
private static String readRequestBody(HttpRequest request) throws IOException {
    StringBuilder sb = new StringBuilder();
    BufferedReader reader = request.getBody();
    String line;
    
    boolean first = true;
    while ((line = reader.readLine()) != null) {
        if (!first) {
            sb.append(CRLF);  // ← 줄바꿈을 CRLF로 복원
        }
        sb.append(line);
        first = false;
    }
    
    return sb.toString();
}
```

---

## 5. MultipartParser 코드 상세 분석

### 5.1 클래스 구조와 상수 정의

```java
public class MultipartParser {
    // HTTP multipart 관련 상수들
    private static final String BOUNDARY_PREFIX = "--";           // boundary 앞에 붙는 구분자
    private static final String CONTENT_DISPOSITION = "Content-Disposition";  // 파트 정보 헤더
    private static final String CONTENT_TYPE = "Content-Type";    // 파일 타입 헤더
    private static final String FORM_DATA = "form-data";          // 폼 데이터 타입
    private static final String FILENAME = "filename";            // 파일명 속성
    private static final String NAME = "name";                    // 필드명 속성
    private static final String CRLF = "\r\n";                   // HTTP 표준 줄바꿈
}
```

### 5.2 메인 파싱 메서드

```java
/**
 * HttpRequest를 MultipartRequest로 파싱합니다.
 * 
 * 파싱 과정:
 * 1. Content-Type 검증 (multipart/form-data인지 확인)
 * 2. boundary 추출
 * 3. 요청 본문 읽기
 * 4. boundary로 part들 분리
 * 5. 각 part를 파일/일반필드로 구분
 * 6. MultipartRequest 객체 생성
 */
public static MultipartRequest parseRequest(HttpRequest request) throws IOException {
    // 1. Content-Type 검증
    String contentType = request.getHeader("Content-Type");
    if (contentType == null || !contentType.toLowerCase().startsWith("multipart/form-data")) {
        throw new IllegalArgumentException("Request is not multipart/form-data");
    }
    
    // 2. boundary 추출 - 각 part를 구분하는 구분자
    String boundary = extractBoundary(contentType);
    if (boundary == null) {
        throw new IllegalArgumentException("No boundary found in Content-Type");
    }
    
    // 3. 요청 본문 읽기 - CRLF 보존하며 전체 내용 읽기
    String body = readRequestBody(request);
    
    // 4. 기존 파라미터 복사 및 새로운 컬렉션 초기화
    Map<String, List<String>> parameters = new HashMap<>(request.getParameters());
    Map<String, List<MultipartFile>> files = new HashMap<>();
    
    // 5. boundary로 part들 분리하고 파싱
    parseParts(body, boundary, parameters, files);
    
    // 6. 파싱 결과로 MultipartRequest 생성
    return new MultipartRequest(
        request.getMethod(),
        request.getPath(),
        request.getHeaders(),
        parameters,
        request.getBody(),
        files
    );
}
```

### 5.3 Boundary 추출 메서드

```java
/**
 * Content-Type 헤더에서 boundary를 추출합니다.
 * 
 * 예시:
 * Input: "multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW"
 * Output: "----WebKitFormBoundary7MA4YWxkTrZu0gW"
 * 
 * 처리 과정:
 * 1. ';'로 파라미터들 분리
 * 2. 'boundary=' 찾기
 * 3. 따옴표 제거 (있는 경우)
 */
private static String extractBoundary(String contentType) {
    String[] parts = contentType.split(";");  // "multipart/form-data"와 "boundary=XXX" 분리
    
    for (String part : parts) {
        part = part.trim();  // 공백 제거
        
        if (part.startsWith("boundary=")) {
            String boundary = part.substring("boundary=".length()).trim();
            
            // RFC에 따라 boundary는 따옴표로 감쌀 수 있음: boundary="----WebKit..."
            if (boundary.startsWith("\"") && boundary.endsWith("\"")) {
                boundary = boundary.substring(1, boundary.length() - 1);  // 따옴표 제거
            }
            
            return boundary;
        }
    }
    
    return null;  // boundary를 찾지 못함
}
```

### 5.4 요청 본문 읽기 메서드

```java
/**
 * 요청 본문을 문자열로 읽으면서 CRLF를 보존합니다.
 * 
 * 중요한 점:
 * - BufferedReader.readLine()은 줄바꿈 문자를 제거함
 * - HTTP에서는 CRLF(\r\n)가 중요하므로 수동으로 복원해야 함
 * - 첫 번째 줄 앞에는 CRLF를 붙이지 않음
 */
private static String readRequestBody(HttpRequest request) throws IOException {
    StringBuilder sb = new StringBuilder();
    BufferedReader reader = request.getBody();
    String line;
    
    boolean first = true;  // 첫 번째 줄 체크용
    
    while ((line = reader.readLine()) != null) {
        if (!first) {
            sb.append(CRLF);  // 이전 줄 끝에 CRLF 추가
        }
        sb.append(line);      // 현재 줄 내용 추가
        first = false;
    }
    
    return sb.toString();
}
```

### 5.5 Part 분리 메서드

```java
/**
 * boundary를 기준으로 파트를 분리하고 파싱합니다.
 * 
 * Multipart 구조:
 * --boundary
 * [part1 content]
 * --boundary
 * [part2 content]
 * --boundary--  (종료)
 */
private static void parseParts(String body, String boundary, 
                             Map<String, List<String>> parameters,
                             Map<String, List<MultipartFile>> files) {
    
    // boundary에 -- 접두사 추가 (HTTP 표준)
    String delimiter = BOUNDARY_PREFIX + boundary;        // "--boundary"
    String endDelimiter = delimiter + BOUNDARY_PREFIX;    // "--boundary--"
    
    // 첫 번째와 마지막 boundary 위치 찾기
    int startIndex = body.indexOf(delimiter);             // 첫 boundary 위치
    int endIndex = body.lastIndexOf(endDelimiter);        // 종료 boundary 위치
    
    if (startIndex == -1) {
        return;  // boundary를 찾을 수 없음 - 잘못된 형식
    }
    
    // 실제 내용 부분만 추출 (시작 boundary 이후, 종료 boundary 이전)
    String content = body.substring(
        startIndex + delimiter.length(), 
        endIndex != -1 ? endIndex : body.length()
    );
    
    // delimiter로 각 part 분리
    String[] parts = content.split(delimiter);
    
    // 각 part 개별 처리
    for (String part : parts) {
        part = part.trim();  // 앞뒤 공백 제거
        if (!part.isEmpty()) {
            parsePart(part, parameters, files);  // 개별 part 파싱
        }
    }
}
```

### 5.6 개별 Part 파싱 메서드

```java
/**
 * 개별 파트를 파싱하여 파일 또는 일반 파라미터로 분류합니다.
 * 
 * Part 구조:
 * Content-Disposition: form-data; name="fieldname"; filename="file.txt"
 * Content-Type: text/plain
 * \r\n              ← 헤더와 본문 구분하는 빈 줄
 * [실제 데이터]
 */
private static void parsePart(String part, 
                            Map<String, List<String>> parameters,
                            Map<String, List<MultipartFile>> files) {
    
    // 1. 헤더와 본문 분리
    int headerEndIndex = part.indexOf(CRLF + CRLF);  // 빈 줄 찾기 (\r\n\r\n)
    if (headerEndIndex == -1) {
        return;  // 올바르지 않은 part 형식 - 헤더와 본문 구분이 없음
    }
    
    // 헤더 섹션과 본문 섹션 분리
    String headerSection = part.substring(0, headerEndIndex);
    String bodySection = part.substring(headerEndIndex + (CRLF + CRLF).length());
    
    // 2. 헤더 파싱 (이름:값 형태로 변환)
    Map<String, String> headers = parseHeaders(headerSection);
    
    // 3. Content-Disposition 헤더 확인
    String contentDisposition = headers.get(CONTENT_DISPOSITION.toLowerCase());
    if (contentDisposition == null || !contentDisposition.toLowerCase().contains(FORM_DATA)) {
        return;  // form-data가 아니면 처리하지 않음
    }
    
    // 4. 필드명과 파일명 추출
    String name = extractAttribute(contentDisposition, NAME);          // name="fieldname"
    String filename = extractAttribute(contentDisposition, FILENAME);  // filename="file.txt"
    
    if (name == null) {
        return;  // 필드명이 없으면 무시
    }
    
    // 5. 파일 vs 일반 파라미터 구분
    if (filename != null) {
        // 파일 파라미터 - filename 속성이 있으면 파일
        String contentType = headers.get(CONTENT_TYPE.toLowerCase());
        byte[] fileContent = bodySection.getBytes(StandardCharsets.UTF_8);
        
        MultipartFile multipartFile = new StandardMultipartFile(
            name, filename, contentType, fileContent
        );
        
        // 같은 이름의 파일이 여러 개일 수 있으므로 List 사용
        files.computeIfAbsent(name, k -> new ArrayList<>()).add(multipartFile);
    } else {
        // 일반 파라미터 - filename이 없으면 텍스트 필드
        parameters.computeIfAbsent(name, k -> new ArrayList<>()).add(bodySection);
    }
}
```

### 5.7 헤더 파싱 메서드

```java
/**
 * 헤더 섹션을 파싱하여 이름:값 맵으로 변환합니다.
 * 
 * 입력 예시:
 * Content-Disposition: form-data; name="file"; filename="test.txt"
 * Content-Type: text/plain
 * 
 * 출력: {"content-disposition": "form-data; name=\"file\"; filename=\"test.txt\"",
 *        "content-type": "text/plain"}
 */
private static Map<String, String> parseHeaders(String headerSection) {
    Map<String, String> headers = new HashMap<>();
    String[] lines = headerSection.split(CRLF);  // 각 줄로 분리
    
    for (String line : lines) {
        line = line.trim();
        if (line.isEmpty()) {
            continue;  // 빈 줄 무시
        }
        
        int colonIndex = line.indexOf(':');  // ':' 위치 찾기
        if (colonIndex > 0) {  // ':' 가 있고 첫 문자가 아닌 경우
            String headerName = line.substring(0, colonIndex).trim().toLowerCase();
            String headerValue = line.substring(colonIndex + 1).trim();
            headers.put(headerName, headerValue);
        }
    }
    
    return headers;
}
```

### 5.8 속성 추출 메서드

```java
/**
 * Content-Disposition에서 특정 속성값을 추출합니다.
 * 
 * 처리 가능한 형태:
 * - name="value"     (따옴표 있음)
 * - name=value       (따옴표 없음)
 * 
 * 예시:
 * Input: 'form-data; name="file"; filename="test.txt"'
 * extractAttribute(input, "name") → "file"
 * extractAttribute(input, "filename") → "test.txt"
 */
private static String extractAttribute(String contentDisposition, String attributeName) {
    // 1. 따옴표가 있는 형태 찾기: name="value"
    String pattern1 = attributeName + "=\"";
    String pattern2 = attributeName + "=";
    
    int startIndex = contentDisposition.indexOf(pattern1);
    if (startIndex != -1) {
        // name="value" 형태 처리
        startIndex += pattern1.length();                    // "name=\"" 다음부터
        int endIndex = contentDisposition.indexOf('"', startIndex);  // 닫는 따옴표 찾기
        if (endIndex != -1) {
            return contentDisposition.substring(startIndex, endIndex);
        }
    } else {
        // 2. 따옴표가 없는 형태 찾기: name=value
        startIndex = contentDisposition.indexOf(pattern2);
        if (startIndex != -1) {
            startIndex += pattern2.length();               // "name=" 다음부터
            int endIndex = contentDisposition.indexOf(';', startIndex);  // 다음 ';' 또는 끝까지
            if (endIndex == -1) {
                endIndex = contentDisposition.length();    // 마지막 속성인 경우
            }
            return contentDisposition.substring(startIndex, endIndex).trim();
        }
    }
    
    return null;  // 속성을 찾지 못함
}
```

---

## 6. 파일 업로드 시스템 아키텍처

### 6.1 전체 시스템 구조

```
클라이언트 (브라우저)
        ↓ Multipart HTTP Request
┌─────────────────────────────────┐
│        Dispatcher               │
│  ┌─────────────────────────────┐│
│  │   Multipart 요청 감지       ││
│  │   Content-Type 확인         ││
│  └─────────────────────────────┘│
└─────────────────────────────────┘
        ↓
┌─────────────────────────────────┐
│     MultipartParser             │
│  ┌─────────────────────────────┐│
│  │   Boundary 추출             ││
│  │   Part 분리                 ││
│  │   헤더/본문 파싱            ││
│  │   파일/텍스트 구분          ││
│  └─────────────────────────────┘│
└─────────────────────────────────┘
        ↓
┌─────────────────────────────────┐
│    MultipartRequest             │
│  ┌─────────────────────────────┐│
│  │   파일 맵 관리              ││
│  │   파라미터 맵 관리          ││
│  │   MultipartFile 객체들      ││
│  └─────────────────────────────┘│
└─────────────────────────────────┘
        ↓
┌─────────────────────────────────┐
│   ParameterResolver             │
│  ┌─────────────────────────────┐│
│  │   @RequestParam 처리        ││
│  │   MultipartFile 바인딩      ││
│  │   메서드 파라미터 생성      ││
│  └─────────────────────────────┘│
└─────────────────────────────────┘
        ↓
┌─────────────────────────────────┐
│      Controller                 │
│  ┌─────────────────────────────┐│
│  │   파일 저장 로직            ││
│  │   비즈니스 로직 처리        ││
│  │   응답 생성                 ││
│  └─────────────────────────────┘│
└─────────────────────────────────┘
```

### 6.2 데이터 흐름

```
1. 클라이언트 요청
   ┌─────────────────────────────────┐
   │ POST /upload HTTP/1.1           │
   │ Content-Type: multipart/form-data; boundary=XXX
   │ Content-Length: 12345           │
   │                                 │
   │ --XXX                           │
   │ Content-Disposition: form-data; name="file"; filename="image.jpg"
   │ Content-Type: image/jpeg        │
   │                                 │
   │ [바이너리 데이터...]           │
   │ --XXX--                         │
   └─────────────────────────────────┘

2. Dispatcher 처리
   ┌─────────────────────────────────┐
   │ if (isMultipartRequest()) {     │
   │     MultipartRequest req =      │
   │         MultipartParser.parse(request);
   │     // 파싱된 요청으로 변환     │
   │ }                               │
   └─────────────────────────────────┘

3. MultipartParser 파싱
   ┌─────────────────────────────────┐
   │ 1. boundary 추출               │
   │ 2. 본문을 boundary로 분리      │
   │ 3. 각 part의 헤더 파싱         │
   │ 4. 파일/텍스트 구분            │
   │ 5. MultipartFile 객체 생성     │
   └─────────────────────────────────┘

4. ParameterResolver 바인딩
   ┌─────────────────────────────────┐
   │ @RequestParam("file")           │
   │ MultipartFile file              │
   │   ↓                             │
   │ multipartRequest.getFile("file")│
   └─────────────────────────────────┘

5. Controller 처리
   ┌─────────────────────────────────┐
   │ public String upload(           │
   │   @RequestParam("file") MultipartFile file
   │ ) {                             │
   │     file.transferTo(new File(...));
   │     return "success";           │
   │ }                               │
   └─────────────────────────────────┘
```

### 6.3 주요 컴포넌트 역할

#### MultipartFile 인터페이스
```java
public interface MultipartFile {
    String getName();           // 폼 필드명
    String getOriginalFilename(); // 원본 파일명
    String getContentType();    // MIME 타입
    long getSize();            // 파일 크기
    byte[] getBytes();         // 파일 내용
    void transferTo(File dest); // 파일 저장
}
```

#### StandardMultipartFile 구현체
```java
public class StandardMultipartFile implements MultipartFile {
    private final String name;          // 폼 필드명
    private final String originalFilename; // 원본 파일명
    private final String contentType;   // MIME 타입
    private final byte[] content;       // 파일 데이터
    
    // 파일 저장, 스트림 제공 등의 기능 구현
}
```

---

## 7. 핵심 질문들에 대한 답변

### Q1: CRLF를 없애는 이유가 무엇인가?

**정확히는 "없애는" 것이 아니라 "보존"하는 것입니다.**

```java
// BufferedReader.readLine()은 줄바꿈 문자를 제거합니다
String line = reader.readLine(); // "Content-Type: image/jpeg" (CRLF 제거됨)

// 하지만 HTTP에서는 CRLF가 중요하므로 수동으로 복원해야 합니다
if (!first) {
    sb.append(CRLF);  // 이전 줄 끝에 CRLF 추가
}
sb.append(line);      // 현재 줄 추가
```

**이유:**
1. **HTTP 표준 준수**: HTTP는 CRLF(\r\n)를 줄바꿈으로 사용
2. **헤더/본문 구분**: `\r\n\r\n`으로 헤더와 본문을 구분
3. **바이너리 데이터 보존**: 파일 내용의 줄바꿈도 정확히 보존해야 함

### Q2: Boundary란 무엇인가?

**Boundary는 multipart 메시지에서 각 part를 구분하는 고유한 문자열입니다.**

```
실제 예시:
------WebKitFormBoundary7MA4YWxkTrZu0gW    ← Part 1 시작
[Part 1 내용]
------WebKitFormBoundary7MA4YWxkTrZu0gW    ← Part 1 끝, Part 2 시작
[Part 2 내용]  
------WebKitFormBoundary7MA4YWxkTrZu0gW--  ← Part 2 끝, 메시지 종료
```

**특징:**
- 메시지 내용에 나타나지 않는 고유한 문자열
- 브라우저가 랜덤하게 생성
- RFC 2046 표준을 따름

### Q3: parseParts에서 boundary로 파트를 분리하는 이유?

**Multipart 메시지는 boundary로만 각 part를 구분할 수 있기 때문입니다.**

```java
// 잘못된 방법: 단순 문자열 분리
String[] parts = body.split("\n");  // ❌ 파일 내용에도 \n이 있을 수 있음

// 올바른 방법: boundary로 분리  
String[] parts = content.split(delimiter);  // ✅ boundary는 고유하므로 안전
```

**이유:**
1. **고유성**: Boundary는 메시지 내용에 나타나지 않음
2. **표준 준수**: RFC 2388 multipart 표준
3. **안전성**: 파일 내용과 구분자가 겹치지 않음

### Q4: -1의 의미는?

**Java에서 `indexOf()`, `lastIndexOf()` 메서드가 찾는 문자열이 없을 때 반환하는 값입니다.**

```java
int startIndex = body.indexOf(delimiter);     // boundary를 못 찾으면 -1
int endIndex = body.lastIndexOf(endDelimiter); // 종료 boundary를 못 찾으면 -1

if (startIndex == -1) {
    return;  // boundary가 없다 = 잘못된 multipart 형식
}

// 종료 boundary가 없어도 처리 가능 (선택적)
String content = body.substring(
    startIndex + delimiter.length(), 
    endIndex != -1 ? endIndex : body.length()  // -1이면 끝까지
);
```

**의미:**
- `startIndex == -1`: 시작 boundary가 없음 → 잘못된 형식
- `endIndex == -1`: 종료 boundary가 없어도 처리 가능

### Q5: CRLF를 자주 사용하는 이유?

**HTTP와 MIME 표준에서 줄바꿈으로 CRLF를 사용하기 때문입니다.**

```java
private static final String CRLF = "\r\n";

// 사용 예시들:
int headerEndIndex = part.indexOf(CRLF + CRLF);  // 헤더 끝 찾기
String[] lines = headerSection.split(CRLF);      // 헤더 줄별 분리
sb.append(CRLF);                                 // 줄바꿈 추가
```

**이유:**
1. **HTTP 표준**: RFC 2616에서 CRLF 사용 규정
2. **호환성**: 모든 시스템에서 동일하게 처리
3. **정확성**: 다른 줄바꿈 문자 사용 시 파싱 오류 발생
4. **바이너리 안전성**: 파일 내용 손상 방지

---



### 1. 성능 최적화 고려사항
- **대용량 파일**: 메모리에 모두 로드하지 않고 스트림 처리
- **임시 파일**: 큰 파일은 임시 파일로 저장 후 처리
- **멀티스레딩**: 여러 파일 동시 업로드 처리

### 2. 보안 고려사항
- **파일 크기 제한**: DoS 공격 방지
- **파일 타입 검증**: 실제 파일 내용과 확장자 일치 확인
- **경로 조작 방지**: 파일명에서 `../` 등 제거
- **바이러스 스캔**: 업로드된 파일 검사

### 3. 에러 처리
- **잘못된 boundary**: 파싱 실패 시 적절한 에러 메시지
- **손상된 데이터**: 헤더 파싱 실패 시 처리
- **용량 초과**: 파일 크기 제한 초과 시 처리