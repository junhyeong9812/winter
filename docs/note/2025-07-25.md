# Java extends와 implements 개념 정리

## 1. extends (상속)

### 개념
- **상속(Inheritance)**을 구현하는 키워드
- 부모 클래스의 속성과 메서드를 자식 클래스가 물려받는 것
- "~은 ~이다 (is-a)" 관계를 표현

### 특징
- **단일 상속**: 자바에서는 하나의 클래스만 상속 가능
- **코드 재사용**: 부모 클래스의 코드를 재사용할 수 있음
- **메서드 오버라이딩**: 부모 클래스의 메서드를 재정의 가능
- **접근 제어**: protected, public 멤버에 접근 가능

### 사용법
```java
// 부모 클래스
class Animal {
    protected String name;
    
    public void eat() {
        System.out.println("동물이 먹습니다.");
    }
    
    public void sleep() {
        System.out.println("동물이 잠을 잡니다.");
    }
}

// 자식 클래스
class Dog extends Animal {
    public void bark() {
        System.out.println("개가 짖습니다.");
    }
    
    // 메서드 오버라이딩
    @Override
    public void eat() {
        System.out.println("개가 사료를 먹습니다.");
    }
}
```

## 2. implements (구현)

### 개념
- **인터페이스(Interface)**를 구현하는 키워드
- 인터페이스에 정의된 추상 메서드들을 반드시 구현해야 함
- "~을 할 수 있다 (can-do)" 관계를 표현

### 특징
- **다중 구현**: 여러 개의 인터페이스를 동시에 구현 가능
- **강제 구현**: 모든 추상 메서드를 반드시 구현해야 함
- **계약(Contract)**: 인터페이스는 클래스가 지켜야 할 약속을 정의
- **다형성**: 인터페이스 타입으로 객체를 참조할 수 있음

### 사용법
```java
// 인터페이스 정의
interface Flyable {
    void fly();
    void land();
}

interface Swimmable {
    void swim();
}

// 인터페이스 구현
class Duck implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("오리가 날아갑니다.");
    }
    
    @Override
    public void land() {
        System.out.println("오리가 착륙합니다.");
    }
    
    @Override
    public void swim() {
        System.out.println("오리가 수영합니다.");
    }
}
```

## 3. 주요 차이점

| 구분 | extends | implements |
|------|---------|------------|
| **대상** | 클래스 상속 | 인터페이스 구현 |
| **개수** | 단일 상속 (1개만) | 다중 구현 (여러 개) |
| **관계** | is-a 관계 | can-do 관계 |
| **구현** | 선택적 오버라이딩 | 모든 메서드 필수 구현 |
| **코드 재사용** | 부모 클래스 코드 재사용 | 인터페이스는 구현부 없음 |
| **접근 제어** | protected 멤버 접근 가능 | public 메서드만 접근 |

## 4. 동시 사용 예제

```java
// 부모 클래스
abstract class Vehicle {
    protected String brand;
    
    public Vehicle(String brand) {
        this.brand = brand;
    }
    
    public void start() {
        System.out.println(brand + " 시동을 걸었습니다.");
    }
    
    // 추상 메서드
    public abstract void move();
}

// 인터페이스들
interface Flyable {
    void takeOff();
    void fly();
    void land();
}

interface Floatable {
    void floatOnWater();
}

// 상속과 구현을 동시에 사용
class Airplane extends Vehicle implements Flyable {
    public Airplane(String brand) {
        super(brand);
    }
    
    @Override
    public void move() {
        System.out.println("비행기가 이동합니다.");
    }
    
    @Override
    public void takeOff() {
        System.out.println("비행기가 이륙합니다.");
    }
    
    @Override
    public void fly() {
        System.out.println("비행기가 비행합니다.");
    }
    
    @Override
    public void land() {
        System.out.println("비행기가 착륙합니다.");
    }
}

class Seaplane extends Vehicle implements Flyable, Floatable {
    public Seaplane(String brand) {
        super(brand);
    }
    
    @Override
    public void move() {
        System.out.println("수상 비행기가 이동합니다.");
    }
    
    @Override
    public void takeOff() {
        System.out.println("수상 비행기가 물 위에서 이륙합니다.");
    }
    
    @Override
    public void fly() {
        System.out.println("수상 비행기가 비행합니다.");
    }
    
    @Override
    public void land() {
        System.out.println("수상 비행기가 물 위에 착륙합니다.");
    }
    
    @Override
    public void floatOnWater() {
        System.out.println("수상 비행기가 물 위에 떠 있습니다.");
    }
}
```

## 5. 사용 가이드라인

### extends를 사용할 때
- 명확한 is-a 관계가 성립할 때
- 코드 재사용이 주목적일 때
- 공통된 속성과 기능을 가진 객체들을 모델링할 때

### implements를 사용할 때
- 특정 기능이나 능력을 표현할 때
- 다양한 클래스가 동일한 동작을 보장해야 할 때
- 다중 상속이 필요한 상황일 때

### 모범 사례
1. **상속보다는 구성(Composition)을 고려**하기
2. **인터페이스를 통한 추상화** 적극 활용
3. **LSP(리스코프 치환 원칙)** 준수
4. **과도한 상속 깊이** 피하기

## 6. 요약

- **extends**: 클래스 간의 상속 관계를 정의하며, 코드 재사용과 is-a 관계를 표현
- **implements**: 인터페이스 구현을 통해 can-do 관계를 표현하고, 다중 구현이 가능
- 두 키워드는 상호 배타적이지 않으며, 하나의 클래스에서 동시에 사용 가능
- 올바른 객체지향 설계를 위해 각각의 특성과 용도를 이해하고 적절히 활용하는 것이 중요