# 자바 제네릭 메서드 `<T> T` 구조 완벽 가이드

## 1. 기본 구조 분해

```java
public static <T> T convert(String value, Class<T> targetType)
//            ↑   ↑
//            │   └── 반환 타입으로 사용되는 T
//            └────── 타입 파라미터를 선언하는 <T>
```

## 2. 각 부분의 역할

### `<T>` - **타입 파라미터 선언부**
- "이 메서드에서 T라는 타입 변수를 사용하겠다"고 선언
- 메서드 호출 시점에 실제 타입으로 결정됨
- 반드시 반환 타입 앞에 위치해야 함

### `T` - **선언된 타입 변수 사용**
- 앞에서 선언한 T를 실제로 사용하는 부분
- 반환 타입, 매개변수 타입 등에서 사용 가능

## 3. 단계별 이해

### Step 1: 선언 없이 사용하면?
```java
// ❌ 에러 발생
public static T convert(String value) // T가 뭔지 모름
```

### Step 2: 선언 후 사용
```java
// ✅ 정상 동작
public static <T> T convert(String value, Class<T> targetType)
//            선언    사용
```

## 4. 실제 동작 예시

```java
// 호출할 때
String result = convert("123", String.class);
// 컴파일러가 이렇게 이해함:
// <String> String convert(String value, Class<String> targetType)

Integer number = convert("456", Integer.class);  
// 컴파일러가 이렇게 이해함:
// <Integer> Integer convert(String value, Class<Integer> targetType)
```

## 5. 다른 제네릭 패턴들과 비교

```java
// 1. 제네릭 클래스의 경우
class Box<T> {
    private T item;
    public T getItem() { return item; } // 클래스 레벨의 T 사용
}

// 2. 제네릭 메서드의 경우  
public static <T> T process(T input) { // 메서드 레벨의 T 선언 + 사용
    return input;
}

// 3. 여러 타입 파라미터
public static <T, U, V> T complex(U input, Class<V> type) {
    // T, U, V 모두 사용 가능
}
```

## 6. 핵심 규칙

1. **선언 위치**: 반환 타입 바로 앞 `<T>`
2. **사용 범위**: 해당 메서드 내에서만 유효
3. **타입 결정**: 메서드 호출 시점에 실제 타입으로 결정
4. **네이밍**: 보통 T, U, V 또는 의미 있는 이름 사용

## 7. 쉬운 암기법

```
<T> T method() 
 │   │
 │   └── "T 타입을 반환한다"
 └────── "T라는 타입을 정의한다"
```

**"T를 정의하고, T를 사용한다"**로 기억하면 됩니다!

## 8. 추가 예시

### 기본 제네릭 메서드
```java
public static <T> T identity(T input) {
    return input;
}

// 사용
String str = identity("Hello");
Integer num = identity(42);
```

### 제한된 제네릭 메서드
```java
public static <T extends Number> double convertToDouble(T number) {
    return number.doubleValue();
}

// 사용
double d1 = convertToDouble(42);      // Integer
double d2 = convertToDouble(3.14f);   // Float
```

### 여러 타입 파라미터
```java
public static <K, V> Map<K, V> createMap(K key, V value) {
    Map<K, V> map = new HashMap<>();
    map.put(key, value);
    return map;
}

// 사용
Map<String, Integer> map = createMap("count", 5);
```