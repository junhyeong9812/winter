# 📘 Dispatcher \~ HandlerAdapter 흐름 요약 (1\~4)

```
최초에 스프링은 Dispatcher라는 클래스에서 
최초로 URL이 키며 컨트롤러가 오브젝트인 핸들러매핑을 위해 해쉬맵을 만든다.
그리고 이를 Dispatcher 생성자에서
생성된 해쉬맵 안에 URL와 컨트롤러를 매핑시켜놓는다.
그 후
실제 내부 dispatch함수에서는
경로를 받아서
해당 맨들러 해쉬맵에서 해당 경로값을 통해 컨트롤러 오브젝트를 가져오고
만약 경로가 없을 경우 null이 들어오기 때문에 이를 통해 404에러 핸들러를 처리한다.
그 후 그 아래 instanceof를 통해 각 핸들러가 해당 컨트롤러가 맞는 지 비교 후
맞다면
해당 컨트롤러의 핸들함수를 동작시키고 그 외 등록은 됐지만 타입이 없다면
500 서버에러를 발생시키는 구조가 최초의 디스패치 구조였다.

그리고 이때
생성자를 통해 HashMap이라는 메모리에 데이터 경로를 매핑시키는 작업을
HandlerMapping이라는 함수로 분리를 한 구조가 된다.
그렇기 때문에 이후에는 디스패처의 생성자는 없애고 바로 매핑해놓은 해쉬맵 객체를 통해 디스패치 함수로 경로를 통해 오브젝트를 가져오도록 한다.
그리고 핸들러매핑으로 핸들러 매핑을 불러오도록 해놨구나.
그리고 거기서 생성자에서 매핑을 하고
get함수를 통해 경로에 대한 매핑 값을 반환하도록 위임된 구조구나.

그리고 이후 나온 Controller란 
결국 하나의 거대한 인터페이스로 Controller가 필수적으로 가지고 있어야 하는 핸들 함수를 생성하도록 제한하여 역할을 확실히 잡는 역할을 해준게 초기의
controller였다는거네
그리고 디스패처에서 controller를 상속 받은 객체에 대해서만 컨트롤러 처리를 하도록 하여 기존에는 if/else if를 통해 각각의 
컨트롤러 객체를 비교해야 됐지만 이제는 그냥 상위 객체인 컨트롤러 상속 객체를 비교해서 해당 컨트롤러의 핸들 함수를 동작하도록 단순화 시켰구나.
쉽게 말해서 여긴 리팩토링을 역할 분리가 아닌 객체의 특성을 가지고 코드를 단순화했던 사례가 되겠구나.

그리고 마지막으로 핸들러 어댑터란? 기존의 코드 구조에서는 결국 instanceof를 통해 해당 객체의 핸들러를 가져와서 직접 실행헀지만
이 동작에서 support가 있는 이유는 해당 오브젝트의 타입을 알아야 하기 때문에 해당 오브젝트를 받아서 판별하는 support함수와
실제 실행하는 핸들러 실행 함수를 핸들러 어댑터로 이 작업을 내눈거구나?
그리고 이때 해당 어뎁터는 상위 인터페이스이며
그 아래 구현체 중 우리는 현재 ControllerHandlerAdapter에 support함수를 통해 해당 객체가 컨트롤러를 상속받는 지 판단하고 
컨트롤러라면 이걸 안전하게 실행하기 위해 캐스팅까지 하고 핸들러 함수를 동작하는 구조가 되고
이렇다면 이후 ServiceHandler는 support에서 서비스 판별 후 해당 핸들러 함수를 구동하는 구조가 되겠구나?
이렇게 되면 결국 이후에는 어댑터 목록들을 가져와서 핸들러를 넣으면
그걸로 생성된 객체가 컨트롤러 어댑터에서 support로 컨트롤러 상속이라는 걸 알게 되면 해당 어댑터의 핸들러 함수로 해당 핸들러를 넣어서
안전하게 타입캐스팅으로 컨트롤러 함수를 실행하는 구조가 되었고 이러면 조건이 필요 없이 여기 어댑터에 없으면 500에러가 나오는 구조구나?
```

## 📝 네 정리 내용의 흐름 (보완 및 정리 요약)

### ✅ [1] Dispatcher 초기 구조
Dispatcher는 내부적으로 URL → Controller 객체를 담는 Map<String, Object> 구조를 가짐  
요청이 들어오면 dispatch(String path)를 통해:
- 해당 URL에 매핑된 컨트롤러(Object)를 조회하고
- null이면 404 Not Found 출력
- 타입이 일치하지 않으면 500 Internal Error
- 일치하는 컨트롤러일 경우, 직접 handle() 호출
- 이때는 instanceof HelloController, ByeController 등으로 분기

✔️ 올바른 정리: 구조는 맞고, 문제는 Dispatcher가 너무 많은 책임을 가졌다는 점

---

### ✅ [2] HandlerMapping 분리
기존 Dispatcher의 생성자 내부에서 직접 Map을 초기화하던 라우팅 로직을 HandlerMapping 클래스로 분리  
HandlerMapping은 내부적으로 Map을 생성하고,  
getHandler(path) 메서드를 통해 Dispatcher에게 핸들러 반환

✔️ 정확한 해석: 역할 분리(SRP)로 Dispatcher는 오직 요청을 처리하는 역할에 집중

---

### ✅ [3] Controller 인터페이스 도입
모든 핸들러가 implements Controller 하도록 강제  
Dispatcher는 이제 instanceof Controller만으로 판단  
((Controller) handler).handle() 방식으로 단순화

✔️ 핵심 포인트:
- “객체 간 공통 인터페이스 도입 → 실행 흐름 일원화”라는 객체지향 원칙이 반영됨
- 조건문 제거 + 코드 구조 명확화라는 큰 효과

---

### ✅ [4] HandlerAdapter 도입
실행 로직 자체를 전략 객체(HandlerAdapter) 에게 위임  
Dispatcher는 더 이상 handler 타입을 몰라도 됨

📌 구성 요약:

| 구성                   | 설명                                                   |
|----------------------|------------------------------------------------------|
| HandlerAdapter        | 인터페이스 (supports(), handle())                    |
| ControllerHandlerAdapter | handler instanceof Controller 판단 + 캐스팅 후 실행     |
| Dispatcher            | 반복문 돌며 adapter에게 supports() → 실행              |

❗ 중요: "Dispatcher는 이제 오직 어댑터만 알고, 핸들러는 몰라도 된다"

✔️ 정확한 요약: "핸들러 실행 책임 → 어댑터로 이동 / Dispatcher는 어댑터만 순회"

---

## 🛠 수정이 필요한 부분 (작은 보완)

| 네 정리 내용 | 보완 설명 |
|--------------|-----------|
| “HandlerMapping이라는 함수로 분리한 구조” | 함수가 아닌 **클래스로 분리된 구조** |
| “ServiceHandler” 예시는 추후 확장 개념 | 맞는 방향이지만 **아직은 존재하지 않음** (추후 확장 가능성 O) |
